\documentclass[12pt, a4paper, bibliography=totocnumbered]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{charter}
\usepackage{xcolor}
\usepackage{parskip}

\definecolor{background}{rgb}{0.97, 0.97, 0.97}
\definecolor{comments}{rgb}{0.0, 0.64, 0.0}
\definecolor{keywords}{rgb}{0.0, 0.0, 0.64}
\definecolor{identifiers}{rgb}{0.63, 0.81, 0.94}
\definecolor{strings}{rgb}{1.0, 0.6, 0.4}

\lstset{
    language=haskell,
    basicstyle=\small\ttfamily,
    backgroundcolor=\color{background},
    keywordstyle=\color{keywords}\bfseries,
    commentstyle=\color{comments}\textit,
    stringstyle=\color{strings},
    % identifierstyle=\color{identifiers},
    breakatwhitespace=true,
    breaklines=true,
    keepspaces=true,
    captionpos=b,
    frame=tlbr,    % Margin at all 4 sides
    framesep=4pt,  % Margin size
    framerule=0pt
}

\title{Chesskell: Embedding a Two-Player Game in Haskell's type system}
\subtitle{3rd Year Project Progress Report}
\author{Toby Bailey}
\date{\today}

\begin{document}

\begin{titlepage}
    \maketitle
    \tableofcontents
\end{titlepage}

\section{Introduction}

In 2020, video games are more popular than ever. In the US alone, an ESA report\footnote{\url{https://www.theesa.com/wp-content/uploads/2020/07/Final-Edited-2020-ESA_Essential_facts.pdf}} estimates that there are more than 214 million individuals who play games. Considering this, it's surprising how many games are released with major bugs in their software---some of which end up being so notable that news and footage of them appear on mainstream media\footnote{\url{https://www.bbc.co.uk/news/technology-50156033}}.

As programming languages have evolved, many have begun to address more errors at compile time. Features similar optional types have been added to languages such as Java and C\#, and languages like Rust have pioneered ways of safely handling dynamic allocation through ownership types\footnote{\url{https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html}}. Many compilers now force the developer to handle classes of errors that previously could only be encountered at runtime, such as null pointer exceptions.

% However, the most common programming language used for game development is C\texttt{++} \cite{gamepp}, despite its' lack of safety and allowance of direct pointer arithmetic. C\texttt{++} is chosen for its' speed, but as computers (and gaming consoles) get more powerful, runtime speed becomes less important than developer productivity. Research into bringing more type-safety into game programming environments is rare, and is the niche this project attempts to fill.

However, catching logical errors in imperative languages is almost always done at runtime. Many software systems use runtime features (such as exceptions) to discover and deal with errors and misuse of APIs. Enforcement of invariants and rules is typically dynamic; if a check fails, an exception is thrown and potentially handled. However, if a programmer forgets to implement such a check, the behaviour is unpredictable. A 2007 study \cite{exceptionsusedpoorly} on Java and .NET codebases indicates that exceptions are rarely used to recover from errors, and a 2016 analysis of Java codebases \cite{badjavaexceptions} reveals that exceptions are commonly misused in Java.

Recent versions of the \emph{Glasgow Haskell Compiler} (GHC) support programming at the type level, allowing programmers to compute with types in the same way that languages like C or Python compute with values \cite{yorgey2012giving}, using \emph{type families} \cite{opentfs} \cite{closedtfs} that emulate functions at the type-level. These computations run at compile time, before the compiler generates an executable of the source code, allowing programmers to transform logic errors into type errors \cite{twt}. The exception misuse described above could be avoided by employing logical invariant checks at the type-level, rather than at runtime.

Since these are relatively recent developments, there are few examples of their usage in complex applications. In this project, we show how to utilise type-level programming features in Haskell in order to model the classic board game Chess in Haskell's type system, ruling out invalid moves at the type-level. A Haskell-embedded Domain-Specific Language (DSL), for describing games of chess, will interact with the type-level model. This Embedded DSL (EDSL) will be modelled on Algebraic Notation, a method of writing down the moves associated with a particular match of chess. We implement the full, official FIDE ruleset for chess.

\section{Background}

In fully dependently-typed languages, such as Idris, there is no clear distinction between types and values. Types' definitions depend on values, and vice versa; so types and values are interchangeable in usage. Functions can be written to compute with types, as well as values.

Haskell was not designed to be such a language. In Haskell, values have types, and types have kinds. Types of kind \lstinline{*} (or \lstinline{Type}) have term-level values; \lstinline{Int} has kind \lstinline{*} because it has the inhabitants \lstinline{0}, \lstinline{1}, \lstinline{2}, etc. The \lstinline{-XDataKinds} extension allows the programmer to define other kinds \cite{yorgey2012giving}, but these kinds do not have any term-level values.

During compilation of a Haskell program (by GHC), \emph{type erasure} occurs. At runtime, Haskell types have no representation, and so writing runtime computation for type-level constructs is nigh impossible. Much previous academic work has gone into emulating dependent types in Haskell \cite{singletons}, working around type erasure through clever use of GHC extensions. Chesskell uses many of these techniques to blur the line between types and values, allowing compile-time checking of the rules of chess---as we explain below.

% TODO: A nice diagram??

\subsection{Related Work}

There are many publicly available chess-related programs written in Haskell\footnote{\url{https://github.com/mlang/chessIO}}\footnote{\url{https://github.com/nionita/Barbarossa}}. Many of these are chess engines, which take in a board state and output the move(s) which are strongest, and so therefore perform move checking at the value-level to ensure that the moves that it outputs are valid. Chesskell differs from these in function, in that the end software will not output a list of strong moves; it will simply take in the moves performed, and state whether they are valid chess moves or not. We are not aware of any such type-level chess implementations in Haskell.

There have been allusions to chess at the type-level through solving the N-queens problem in dependently typed languages, such as Idris\footnote{\url{https://github.com/ExNexu/nqueens-idris}}. The N-queens problem makes use of some chess rules, including the Queen's attack positions (a straight line in any direction); but as the end goal is not to successfully model a game of chess, it is not a full type-level chess implementation.

An important part of any good chess program is its board representation, since all other parts of the program come from this; move generation, move evaluation, and the entire search space are all defined or influenced by the board representation. A great deal of work has gone into defining memory- or time-efficient chess boards \cite{bitboard} \cite{searchtables}, including combinations of multiple representations to yield greater speed \cite{bitandccr}. While there is value to be gleaned from examining these representations, Chesskell serves a different purpose; it does not need to search through the valid set of moves to determine which are the best, and speed is not its focus. Chesskell's board representation must be relatively efficient, but it would be naive to expect similar levels of performance from type-level constraint solving computation as from optimised term-level code.

Despite the apparent lack of work on Chess at the type level specifically, there is work on Haskell-Embedded DSLs in other domains to enforce certain behaviour at compile time. Mezzo \cite{mezzohaskellsymposium} is an EDSL for music composition, which checks if the described piece of music conforms to some musical ruleset during compilation of the program. This EDSL is most similar to Chesskell in aim, if not in application domain; performing compile-time checks of rulesets that are commonly checked at runtime.

As another example, BioShake \cite{bioshake} is an EDSL for creating performant bioinformatics computational workflows. The correctness of these workflows is checked during compilation, preventing it from being created if certain errors would occur. For bioinformatics workflows especially, this is ideal since many of these workflows are lengthy. BioShake goes further, however; providing tools to allow parallel execution of these workflows. While it is encouraging to see this (and other EDSLs \cite{aplite}) focus on (and achieve) high performance, Chesskell will have no such focus. This is primarily because only certain parts of the rule-checking process can be parallelised; much of the move handling and order of rule checks must be done sequentially.

% \section{Project Functional Requirements}

% \begin{enumerate}
%     \item The system will contain a type-level model of chess, which will:
%           \begin{enumerate}
%               \item Support all rules within the FIDE official chess rules.
%               \item Have an internal representation of the board, the pieces, and other information relevant to the state of play.
%               \item Be able to detect when a rule of chess has been broken, and give out a compile-time error to explain which rule was broken and how.
%           \end{enumerate}
%     \item This type-level system will run on the Glasgow Haskell Compiler.
%     \item This type-level system will be accessible via an Embedded Domain-Specific Language, which will:
%           \begin{enumerate}
%               \item Describe a game of chess, move by move.
%               \item Be written in Haskell source files, and be valid Haskell according to the Haskell grammar \cite{2010langreport}.
%               \item Be type-checked by the type-level model, and will cause errors if the game described breaks the established rules of chess.
%           \end{enumerate}
% \end{enumerate}

\section{Current Progress} \label{examplegame}

Our EDSL allows us to describe games of chess, move-by-move. For example, we express a simple 3-move checkmate by White as follows in Chesskell:

\begin{lstlisting}
game = chess
            pawn _e2 to _e4
            pawn _f7 to _f5
            queen _d1 to _f3
            pawn _g7 to _g5
            queen _f3 to _h5
        end
\end{lstlisting}

Note that the White team always begins a game of chess, and moves alternate teams; so there is no need to annotate moves with their team.

Each chess move is described with a type family, which takes as input the current state of the board, and outputs the board after the move has been processed. The core movement function, aptly named \lstinline{Move}, takes in the position to move from, the position to move to, and the current state of the board, using this information to produce a new board in which the move has been made:

\begin{lstlisting}
data Move :: Position -> Position -> BoardDecorator -> Exp BoardDecorator
\end{lstlisting}

The EDSL, as we explain in more detail below, uses this \lstinline{Move} function to perform type-level rule checking of the described chess game. While the continuation-passing style (CPS) structure complicates the relevant types, the intuition of the EDSL is to take in the current board state, as well as the positions to move from and to, and output the new board state generated by that move. A simplified non-CPS example is below, to aid understanding:

\begin{lstlisting}
edslMove :: SPosition from -> SPosition to -> Proxy (b :: Board) -> Proxy (Eval (Move from to b))
edslMove (x :: SPosition from) (y :: SPosition to) (z :: Proxy (b :: Board)) = Proxy @(Eval (Move from to b))
\end{lstlisting}

\subsection{Chess Types Overview}

The software has a full representation of a game of chess at the type-level, as we explain below. As the system checks the game move by move, the only required representation is the board at the time of checking; containing all pieces on that board.

The \lstinline{Board} type is the most important type in Chesskell, representing the chess board at the type-level. It is a \emph{composite type} containing all pieces in play. However, \lstinline{Board} types are usually accessed through a type named \lstinline{BoardDecorator}, which contains more information for ease of use (as we detail below).

We describe Chesskell's types from the bottom up in the following sections, since the types here are composite and require understanding of other types.

\subsubsection{Team and PieceName}

Both \lstinline{Team} and \lstinline{PieceName} are simple algebraic data types, with all constructors defined in code. The \lstinline{Team} type enumerates all teams a piece can belong to; \lstinline{Black} and \lstinline{White}. The \lstinline{PieceName} type enumerates all possible names of pieces; pawn, rook, and so on.

The declarations below, combined with the \lstinline{-XDataKinds} extension, create two things. The first is a value-level representation of \lstinline{Team} and \lstinline{Piecename}, where \lstinline{Black} is a value of type \lstinline{Team}. The second is a \emph{type-level} representation, where \lstinline{'Black} is a type of kind \lstinline{Team}\footnote{Note that \lstinline{'Black} has no term-level values, since it does not have kind \lstinline{*}}.

% For values that have been promoted to types, a ' may be prefixed (as with \lstinline{'Black}) above. However, this prefix is optional, since GHC can, in most cases, tell whether something is a value or a type from context. Where unclear, this report will use the prefix to distinguish types from values.

\begin{lstlisting}
data Team = Black | White
data PieceName = Pawn
            | Bishop
            | Knight
            | Rook
            | King
            | Queen
\end{lstlisting}

\subsubsection{Position}

The \lstinline{Position} type holds the positions of pieces on the chess board. It makes use of two more types, one for columns and the other for rows. In chess, columns are labelled with letters and rows are labelled with numbers; "a1" is the top-left of the board, and "h8" is the bottom-right. The \lstinline{Column} type is another simple algebraic data type enumerating all columns that a piece can reside within. The row type is a type-level implementation of Peano natural numbers, named \lstinline{Nat}. Early versions of Chesskell had a custom implementation, but the current version simply uses definitions provided in \lstinline{Data.Type.Nat}.

% The below definition makes use of \emph{Generalised Algebraic Data Type} syntax, or GADT syntax for short. This is an extension to Haskell, allowing programmers to define more complex data types by describing the types of its' type constructors. This is clear below: \lstinline{Z} is a value of type \lstinline{Nat}, while \lstinline{S} is a function that takes in a \lstinline{Nat} and returns another \lstinline{Nat}.

\begin{lstlisting}
data Column = A | B | C | D | E | F | G | H
data Nat where
    Z :: Nat
    S :: Nat -> Nat
\end{lstlisting}

Note that the \lstinline{Position} kind has a potentially infinite number of valid types, but only 64 of these types are valid chess positions. As such, there is a type family, \lstinline{IsValidPosition}, which outputs \lstinline{True} if the given position is a valid chess position, and \lstinline{False} otherwise.

% The Position type itself is a \emph{product type}, a type whose cardinality\footnote{A type's cardinality is the number of inhabitants it has.} is equal to the product of the types it takes in. Since \lstinline{Position} takes in a type of cardinality 8 (\lstinline{Column}) and a type of infinite cardinality (\lstinline{Nat}), it has infinite cardinality, even though only 64 of them are valid chess positions.

\begin{lstlisting}
data Position where
    At :: Column -> Nat -> Position
\end{lstlisting}

\subsubsection{The Pieces}

Each piece, represented by the \lstinline{Piece} type, contains information relevant for rule checking: that piece's team, name, and an information type. The information type, named \lstinline{PieceInfo}, contains a \lstinline{Nat} and a \lstinline{Position}, to represent the number of moves that piece has taken, and its current position on the board respectively. Recording the number of moves the piece has taken is important for several rules in chess, including castling and \textit{En Passant}, and so is included in the \lstinline{PieceInfo} type.

The \lstinline{PieceInfo} type was created separate from the plain \lstinline{Piece} type so that if any further information was needed, it could be added without breaking existing \lstinline{Piece} pattern-match definitions (though no such additional information was required).

\begin{lstlisting}
data PieceInfo where
    Info :: Nat -> Position -> PieceInfo

data Piece where
    MkPiece :: Team -> PieceName -> PieceInfo -> Piece
\end{lstlisting}

\subsubsection{The Board}

At the type level, the most common way of storing n elements is with the built-in list type \lstinline{[]} (similar to the value-level). However, a singly-linked list has issues; how can we ensure that the chess board is the appropriate size (an 8x8 grid) without a length check each move? This would take at least 56 additions, since list length is computed recursively; as well as 7 more addition operations to put together the list lengths.

Performing such a check each move would be wasteful. Instead, length-indexed vectors are used. \lstinline{Nat} values specify the length of a vector, resulting in a type error if the vector is any other length. As with most things in Haskell, we use recursive definitions; an empty vector has length 0, and you express a vector of length (n + 1) by pushing an element to the front of a vector of length n.

\begin{lstlisting}
data Vec (n :: Nat) (a :: Type) where
    VEnd   :: Vec Z a
    (:->)  :: a -> Vec n a -> Vec (S n) a
\end{lstlisting}

For example, a vector of 3 boolean types has the type: \lstinline{Vec (S (S (S Z))) Bool}. The board can be expressed using these vectors---a vector of 8 vectors of 8 \lstinline{Maybe Piece}-s. We use \lstinline{Maybe Piece} instead of just \lstinline{Piece} because a board square does not necessarily contain a piece.

\begin{lstlisting}
type Eight = (S (S (S (S (S (S (S (S Z))))))))
type Row   = Vec Eight (Maybe Piece)
type Board = Vec Eight Row
\end{lstlisting}

Although this is the main board type, it is augmented with a \lstinline{BoardDecorator}, so named because the intention is similar to the decorator design pattern \cite{decorator} (with the exception that subclassing and superclassing are not features of Haskell). \lstinline{BoardDecorator} should be used instead of \lstinline{Board}, since it provides additional information:

\begin{itemize}
    \item The last team to move;
    \item The last position moved to;
    \item The White and Black king positions, stored as a tuple;
    \item The number of moves in the game thus far.
\end{itemize}

Previous versions of the program, to find the king positions, would pass repeatedly over the \lstinline{Board}. Having their positions available in the decorator saves the system from making these passes. While there is the overhead that the \lstinline{BoardDecorator} must be updated at each move, the code is much conceptually clearer with the use of the decorator.

\begin{lstlisting}
data BoardDecorator where
    Dec :: Board -> Team -> Position -> (Position, Position) -> Nat -> BoardDecorator
\end{lstlisting}

\subsection{Checking Chess Rules}

We perform all rule-checking with type families that take in the \lstinline{BoardDecorator} (among other arguments) and output either a correct result, or a type error. Rule-checking occurs during movement, since the chess game effectively hangs while players do not move.

\subsubsection{Type families in Haskell}

Although Haskell allows type-level computation via type families, these type families can't be partially applied like normal Haskell functions can. However, Li-yao Xia's work on First Class Families\footnote{\url{https://github.com/Lysxia/first-class-families}} defines a kind of type-level interpreter, allowing similar behaviour to partial application.

First Class Families are achieved through the definition of an open type family, \lstinline{Eval}, and an expression type, \lstinline{Exp}. In Haskell, type constructors can be partially applied at the type level, where type families cannot. Type-level functions are defined such that their return value is wrapped in an \lstinline{Exp}. Consider a type-level implementation of addition in First Class Family form, and in type family form:

\begin{lstlisting}
data Plus :: Nat -> Nat -> Exp Nat
type instance Eval (Plus x y) = Plus' x y

type family Plus' (n :: Nat) (m :: Nat) :: Nat where
    Plus' Z     m = m
    Plus' (S n) m = S (Plus' n m)
\end{lstlisting}

\lstinline{Plus 4} would be a valid type, with kind \lstinline{Nat -> Exp Nat}; whereas \lstinline{Plus' 4} would result in a type error. With a 

This means that the board is mappable, performing computation on the pieces therein without writing a new function for each map. Incrementing a piece's move count, or changing the name of a piece, is therefore much easier with First Class Families than it would otherwise be with regular type families.

There is one major caveat, though. When pattern-matching with First Class Families, catch-all matches fail to work. That is, the below would fail to compile, since either definition could be valid for \lstinline{Plus Z 5}.

\begin{lstlisting}
data Plus :: Nat -> Nat -> Exp Nat
type instance Eval (Plus Z n) = n
type instance Eval (Plus m n) = -- ...
\end{lstlisting}

However, First Class Family-style definitions can be combined with regular type families to enable pattern matching, as with \lstinline{Plus} and \lstinline{Plus'} above.

\subsubsection{Move Lists}

Each piece, depending on its team and name, can move a certain number of spaces. For instance, a King can move a single space in any direction. The \lstinline{PieceMoveList} type family formalises this, returning a list of spaces that a piece can move to, given that piece as a \lstinline{Piece} type, and a \lstinline{BoardDecorator} representing the current state of the board.

\begin{lstlisting}
data PieceMoveList :: Piece -> BoardDecorator -> Exp [Position]
\end{lstlisting}

Consider a \lstinline{PieceMoveList} instance for Bishops:

\begin{lstlisting}
type instance Eval (PieceMoveList (MkPiece team Bishop info) boardDec) = Eval (AllReachableDiag team boardDec (Eval (GetPosition info)))
\end{lstlisting}

Bishops can move diagonally in a straight line by any number of spaces. The type families \lstinline{AllReachableDiag} is used to get a list of all diagonally "reachable" positions. It takes in the position of the relevant piece, that piece's team, and the current state of the board, and outputs all diagonal positions that piece can move to.

Reachability (for a given direction) is defined here as all the empty spaces in all that direction, stopping at the first occupied space. That space is included or excluded depending on whether that space is occupied by a piece of the opposite team, since an attacking piece could move to that space and take the piece there.

There is another function, \lstinline{PieceAttackList}, which is similar to \lstinline{PieceMoveList} but gives the list of spaces that a piece can attack. This is different from a piece's move list in a handful of cases (for instance, pieces can attack the opposite team's King, but cannot move to its position and take it).

\subsubsection{Moving the Pieces}

\lstinline{Move}, as we introduce above, performs a series of checks on the board state, computes a move from an origin \lstinline{Position} to a destination \lstinline{Position} with a given \lstinline{BoardDecorator}, and then performs further checks. The actual movement code is omitted here for brevity; but all moves are present and complete. The checks themselves are implemented as functions that take in a \lstinline{BoardDecorator}, and output either a \lstinline{BoardDecorator} (if the check passes) or a type error.

\begin{lstlisting}
data Move :: Position -> Position -> BoardDecorator -> Exp BoardDecorator
type instance Eval (Move fromPos toPos boardDec) = Eval ((
    CheckNoCheck (GetMovingTeam boardDec) .
    MoveNoChecks fromPos toPos .
        NotTakingKingCheck toPos .
        CanMoveCheck fromPos toPos .
        NotTakingOwnTeamCheck toPos .
        NotSamePosCheck fromPos toPos .
        NotLastToMoveCheck fromPos .
        TeamCheck fromPos) boardDec)
\end{lstlisting}

\subsection{EDSL}

\subsubsection{Proxies and Singletons}

Type-level information is not naturally available to Haskell's term-level facilities, due to type erasure. As such, there are various methods to simulate computation with types at runtime.

Proxy types are parameterised with kind-polymorphic type variables \cite{yorgey2012giving}. A \lstinline{Proxy} value can have type \lstinline{Proxy Int} or \lstinline{Proxy 'Black}, for example. Proxies are used to make runtime board information available at the type level in Chesskell.

Singleton types mimic dependent types \cite{singletons}; each type has a single, unambiguous value, and vice versa. We use this value to pass around type information at the term-level. Chesskell uses singletons to perform computation with positions and piece names. For example, the value \lstinline{_a4} is has type \lstinline{SPosition (At A (S (S (S (S Z)))))}.

\subsubsection{EDSL Implementation}

A Continuation Passing Style \cite{cps} scheme forms the foundation for the EDSL, with inspiration taken from Dmitrij Szamozvancev's Flat Builders pattern \cite{mezzo}. The core idea is value transformation through a series of continuation function applications, until the final continuation function returns a value.

The type \lstinline{Spec t} is the type of functions which take in a continuation to operate on a value of type \lstinline{t}. For instance, a function with type \lstinline{Int -> Spec Int} would take in an integer, and then a continuation to operate on that integer.

\begin{lstlisting}
type Spec t = forall m. (t -> m) -> m
\end{lstlisting}

A function with type \lstinline{Int -> Spec Int} can be represented with \lstinline{Conv Int Int}---the \lstinline{Conv s t} type represents functions which convert a value of type \lstinline{s} to a value of type \lstinline{Spec t}.

\begin{lstlisting}
type Conv s t = s -> Spec t
\end{lstlisting}

Finally, the \lstinline{Term t r} type ends the continuation stream by taking no continuations, and simply taking in a value of type \lstinline{t} and returning a value of type \lstinline{r}. If \lstinline{t} and \lstinline{r} are equal, then an example definition would be \lstinline{id}.

\begin{lstlisting}
type Term t r = t -> r
\end{lstlisting}

The above continuation types are combined with type-level rule checking, to create a Chess EDSL that operates through passing continuations. Type-level computations within the EDSL are achieved through \emph{type applications} \cite{typeapplication}, which allow the programmer to specify the exact type of a kind-polymorphic type variable. Using a combination of singletons, proxies, kind signatures, and type applications, the value-level Haskell code for the EDSL can have specific type variables and involve type family application. Essentially, the term-level EDSL can involve type-level rule checking.

The chess game starts with a \lstinline{Proxy} value, with its type containing a \lstinline{BoardDecorator} type. Continuations are applied, transforming that value, until the chess game ends (or a rule is broken). Chess games begin with the board in a set configuration; and so a type \lstinline{StartDec} (of kind \lstinline{BoardDecorator}) was defined to contain all of this information.

\begin{lstlisting}
chess :: Spec (Proxy StartDec)
chess cont = cont (Proxy @StartDec)
\end{lstlisting}

The core continuations are named after the pieces, such as \lstinline{pawn} and \lstinline{king}. Each of them takes in an \lstinline{SPosition}, a singleton version of \lstinline{Position}. We define a new datatype, \lstinline{MoveArgs}, in order to simplify the process of passing information between the continuations; \lstinline{MoveArgs} can be partially applied, whereas a regular type family cannot. The example \lstinline{pawn} continuation is used below; however, all of the piece continuations are similar, and only differ in the \lstinline{PieceName} type passed to the continuation via \lstinline{MoveArgs}.

\begin{lstlisting}
data MoveArgs where
    MA :: BoardDecorator -> Position -> PieceName -> Position -> MoveArgs

pawn :: Proxy (b :: BoardDecorator) -> SPosition fromPos -> Spec (Proxy (MA b fromPos 'Pawn))
pawn (dec :: Proxy b) (from :: SPosition fromPos) cont = cont (Proxy @(MA b fromPos Pawn))
\end{lstlisting}

The next continuation, \lstinline{to}, takes in another \lstinline{SPosition}, performs the move computation, puts the resulting board decorator into a \lstinline{Proxy} type, and passes that \lstinline{Proxy} into the continuation given.

\begin{lstlisting}
to :: Proxy (MA (b :: BoardDecorator) (fromPos :: Position) (n :: PieceName)) -> SPosition toPos -> Spec (Proxy (Eval (MoveWithStateCheck n fromPos toPos b)))
to (args :: Proxy (MA (b :: BoardDecorator) (fromPos :: Position) (n :: PieceName))) (to' :: SPosition toPos) cont = cont (Proxy @(Eval (MoveWithStateCheck n fromPos toPos b)))
\end{lstlisting}

The final relevant definition is of \lstinline{end}, which ends the chess game (and the continuation stream).

\begin{lstlisting}
end :: Term (Proxy (b :: BoardDecorator)) (Proxy (b :: BoardDecorator))
end = id
\end{lstlisting}

Using the above continuations, we can lay out a chess game, move by move. Consider the game expressed in the EDSL which we describe in section \ref{examplegame}. It compiles successfully; but should Black attempt to move after checkmate, an error will be logged, since no moves by Black will be valid:

\begin{lstlisting}
-- Below results in the following type error:
    -- * The Black King is in check after a Black move. This is not allowed.
    -- * When checking the inferred type
    --     game :: Data.Proxy.Proxy (TypeError ...)
game = chess
           pawn _e2 to _e4
           pawn _f7 to _f5
           queen _d1 to _f3
           pawn _g7 to _g5
           queen _f3 to _h5
           pawn _g5 to _g4
       end
\end{lstlisting}

Or, should White attempt an impossible move in the middle of the game, such as moving a Queen through another piece, a different type error will occur:

\begin{lstlisting}
-- Below results in the following type error:
    -- * There is no valid move from D1 to D3.
    -- The Queen at D1 can move to: E2, F3, G4, H5
    -- * When checking the inferred type
    -- game :: Data.Proxy.Proxy (...)
game = chess
           pawn _e2 to _e4
           pawn _f7 to _f5
           queen _d1 to _d3
           pawn _g7 to _g5
           queen _f3 to _h5
       end
\end{lstlisting}

\subsubsection{EDSL Board Creation}

There are additional statements to help create an initial chess board for easy testing. A short example is below, in which White Rooks are placed at a8 and h1, and a Black Pawn is placed at h7 before the game begins.

\begin{lstlisting}
example
  = create                 
        put _Wh _R at _a8
        put _Wh _R at _h1
        put _Bl _P at _h7   
    startMoves           
        rook _a8 to _a2
        pawn _h7 to _h6
        rook _h1 to _h2
    end
\end{lstlisting}

\subsubsection{Pawn Promotion}

The EDSL function \lstinline{becomes} handled Pawn promotion in earlier versions of Chesskell, transforming a Pawn into another piece after it has moved to the opposite side of the board. Since the whole chess game is expressed in continuation-passing style, \lstinline{becomes} simply edits a Pawn's \lstinline{PieceName} in place. %, with the help of type family \lstinline{PromotePieceTo}.

\begin{lstlisting}
game = chess
           -- ...
           pawn _a7 to _a8 becomes _Queen
           -- ...
       end
\end{lstlisting}

We can combine this with the board creation functionality to create a simple game which compiles:

\begin{lstlisting}
game = create
           put _Wh _P at _a7
       startMoves
           pawn _a7 to _a8 becomes _Queen
       end
\end{lstlisting}

However, the below code will also compile, when it should not, since according to the FIDE 2018 Laws of Chess\footnote{\url{https://handbook.fide.com/chapter/E012018}}, promotion is not optional, and must occur.

\begin{lstlisting}
game = create
            put _Wh _P at _a7
        startMoves
            pawn _a7 to _a8
        end
\end{lstlisting}

We require additional logic to enforce promotion, in two ways. Firstly, promotion must occur when a pawn reaches the opposite end of the board. Secondly, if a pawn reaches the opposite end of the board but is not promoted, then Chesskell should throw a type error.

Enforcing promotion during movement is achieved with a new check, \lstinline{ShouldHavePromotedCheck}, which checks if a promotion should have occurred\footnote{i.e. if a Pawn reached the opposite end of the board.} and outputs a type error if so, and the inputted \lstinline{BoardDecorator} otherwise. Promotion within the EDSL occurs through a new function, \lstinline{promoteTo}, which uses a type family \lstinline{PromotePawnMove} to promote a Pawn to a given \lstinline{PieceName} after movement. The following code snippet compiles, since the White Pawn is promoted to a Queen:

\begin{lstlisting}
game = create
           put _Wh _P at _h7
       startMoves
           pawn _h7 promoteTo _Queen _h8
       end
\end{lstlisting}

However, the below does not compile, since no promotion occurs even though the White Pawn reaches the opposite end of the board:

\begin{lstlisting}
-- Below results in the following type error:
--     * Promotion should have occurred at: H8. Pawns must be promoted when they reach the opposite end of the board.
--     * When checking the inferred type
--         didntPromoteWhite :: Data.Proxy.Proxy (TypeError ...)
game = create
            put _Wh _P at _h7
        startMoves
            pawn _h7 to _h8
        end
\end{lstlisting}

\subsubsection{EDSL Issues}

GHC had issues compiling early versions of the EDSL, due to the initial definition of \lstinline{chess}; the programmer did not manually create \lstinline{StartDec}, but pieced it together through a series of expensive type family applications:

\begin{lstlisting}
type StartDec = MakeDecorator (ExpensiveOperation (...))
\end{lstlisting}

This early version of \lstinline{StartDec} was used to set up the chess game, with attempts at two definitions of \lstinline{chess}; one using a type application, and the other using a type signature.

\begin{lstlisting}
-- Early definition of chess with type application
chess :: Spec (Proxy StartDec)
chess cont = cont (Proxy @StartDec)

-- Version of chess with type signature
chess :: Spec (Proxy StartDec)
chess cont = cont (Proxy :: Proxy StartDec)
\end{lstlisting}

The version of \lstinline{chess} that used a type application would compile without issues, but would cause lengthy pauses at runtime when used. Conversely, when compiling the type signature version, GHC would consume high amounts of memory, and would either crash or hang for multiple minutes. This behaviour is unusual, so we filed a GHC bug report\footnote{\url{https://gitlab.haskell.org/ghc/ghc/-/issues/18902}}. As a work-around until the bug is fixed, \lstinline{StartDec} is manually written out in full in the source Haskell file, allowing compilation and usage of either definition with no issues.

Additionally, adding the move number to the type error\footnote{e.g. \lstinline{Error at move 1: Pawn cannot move to...}} causes a spike in compile time; not as excessive as above, as GHC does not crash, but still doubling or tripling compile time. The move number will only be re-added to the error if this problem can be fixed or worked around, since it would greatly slow the testing of a large number of games.

\subsection{Testing}

The test suite is a mixture of HSpec behaviour-driven tests \cite{hspec} and module declarations, where the HSpec tests cover many of the declared type families (such as \lstinline{Move} and \lstinline{PieceMoveList}).

The original plan was to have all tests be HSpec tests; many of these HSpec tests make use of the type-level testing facilities laid out in other works \cite{mezzo}. However, running the test suite on EDSL statements, as well as some of the expensive type families (such as those involving castling) causes excessive memory usage, exceeding 27 GB in some cases.

Work on a solution is ongoing, but for now, we express EDSL tests as high-level declarations in a Haskell module. The tests are run by seeing whether these declarations compile or not (and if not, what error they throw). This will hopefully only be temporary, but it should suffice as a rudimentary (if slow) method of integration testing.

\section{Next Steps}

As the project's main feature set is complete, the remaining time will be spent testing, evaluating, and improving the project. Full-length chess games will be expressed in the EDSL, to determine if the program compiles correct chess games. Then, we will introduce subtle errors to those games, to test that incorrect games fail to compile. Of course, the code itself is only part of the project; work on the dissertation should begin early next term/year.

% \subsection{Chess Rules}

% At the moment, the only incomplete chess rule is \emph{mandatory promotion}. Promotion in the EDSL is optional, meaning a Pawn can reach the opposite end of the board and remain a Pawn. The current implementation of promotion does not involve the \lstinline{Move} function, but since pawn promotion must occur by the end of its' move, the \lstinline{Move} function must include this functionality.

\subsection{EDSL}

The EDSL is feature-complete, as far as chess rules go. However, a few additional helper functions or syntax changes may be helpful during development or to clarify their purpose, and so the EDSL is subject to change.

\subsection{Performance}

The current memory usage and compile time of the EDSL is acceptable, but only short ($<$10 moves) chess games have been described and tested thus far. Memory usage and compile time are likely to rise both with the length of the chess game, and the number of games tested. Memory usage optimisations may become necessary as testing continues.

\subsection{Project Extensions}

As the project is nearly complete, it may be worth adding several extensions to further explore Chess at the type level. Some potential extensions are described below.

\subsubsection{Session Types}

\emph{Session types} are formalisms of communication, between two or more parties, at the type level \cite{torinosessions}. Interestingly, chess could theoretically be modelled in terms of communication between two parties, Black and White; they can only send one message at a time to each other, and their communications cannot break the rules of chess. A potential extension would be to conduct more research into this topic, determining how viable a session-typed Chesskell would be, and possibly implementing it (time constraints allowing).

\subsubsection{Haskell Symposium Paper}

Another potential extension is to write a paper on Chesskell for the Haskell Symposium 2021 (either for its early track, or for its regular track). The Haskell Symposium accepts papers on a variety of topics, including language design, experiences, tools, and so on. This would be a good opportunity to gauge academic interest in Chesskell, and contribute to the wider academia surrounding type-level programming.

\subsection{Revised Timetable/Plan}

\subsubsection{Weeks 9-10: 30th November to 13th December}

These two weeks will be spent performing integration/system testing. A curated data set of chess games will be expressed in the EDSL and put through the GHC compiler. Some of these games will be valid, and some will be invalid. Only valid games should compile, and invalid games should fail to compile with an appropriate type error.

\subsubsection{Weeks 11-14: 14th December 2020 to 10th January 2021}

This is the first section of allocated empty space. If the test suite is posing any issues (with regards to compile time and memory usage) then this additional month should help with solving them. But should the testing be going well, then this extra time will be spent either starting early on the dissertation, or adding extensions to the project to further explore Chess at the type level (as we discuss above).

\subsubsection{Weeks 15-18: 11th January to 7th February}

Writing the dissertation is planned for this stretch of time; it will be planned out, section by section, while gathering any relevant graphs, figures, and citations.

The module CS324 Computer Graphics has a coursework due on the 20th January; as such, planning the dissertation could take longer than expected. However, since a month is set aside for just planning, delays are unlikely.

\subsubsection{Weeks 19-22: 8th February to 7th March}

Once the previous detailed planning stage is complete, writing shall begin; with a detailed enough plan, this section should not take longer than a month. We will finish an initial draft by the 7th of March.

The project itself will be evaluated during this period. We will examine the cleaned and completed code for any subtle bugs. Work on the project presentation will also start in earnest, writing out a script.

\subsubsection{Weeks 23-24: 8th March to 21st March}

These two weeks are more empty space; set aside to act as a buffer for delays in dissertation writing. The project presentation occurs on the 19th March; so this empty space will ideally be spent completing the presentation and rehearsing it.

\subsubsection{Weeks 25-29: 22nd March to 25th April}

Drafting, re-drafting, and refining the dissertation (with the help of the supervisor) will take place during this time. This is the final stretch, and will be spent ensuring that the final piece of writing is as good as it can be.

Revision for examinations is key during this period; however, since the dissertation should be complete and this period is for evaluation and not the main bulk of writing, there should be ample time.

% \section{Resources, Risks, and Ethical Considerations}

% \subsection{Resources}

% Developing this program requires a computer (and Operating System) which can run the latest version of GHC (8.10.2, at the time of writing). GHC runs on most Linux distributions, as well as Windows and MacOS. In other words, it runs on almost all consumer-grade PCs, and so suitable development and testing hardware is plenty.

\section{Risks}

The biggest risk going into the project was that it was unachievable; however, that risk has not materialised---the implementation of type-level chess rules is complete. The largest project-related risks left are the memory usage and compile time issues. 

There are, of course, other risks not directly associated with the project; in 2020, there is a large-scale pandemic going on, which could pose considerable personal risk. However, by following Government and University guidelines, the chances of contracting COVID-19 will be kept to a minimum, and sudden illness should not interrupt the project.

% \subsection{Legal, Professional, and Ethical Considerations}

% As this project is undertaken alone, with no involvement from third parties (aside from the project supervisor), there are no additional legal, professional, or ethical considerations to consider. The program contains no personal data processing, and we will not introduce such processing.

\bibliographystyle{ieeetr}

\bibliography{progress}

\end{document}