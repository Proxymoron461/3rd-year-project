\documentclass[12pt, a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{charter}
\usepackage{xcolor}

\definecolor{background}{rgb}{0.97, 0.97, 0.97}
\definecolor{comments}{rgb}{0.0, 0.64, 0.0}
\definecolor{keywords}{rgb}{0.0, 0.0, 0.64}

\lstset{
    language=haskell,
    basicstyle=\small\ttfamily,
    backgroundcolor=\color{background},
    keywordstyle=\color{keywords}\bfseries,
    commentstyle=\color{comments}\textit,
    breakatwhitespace=true,
    breaklines=true,
    keepspaces=true,
    captionpos=b,
    frame=tlbr,    % Margin at all 4 sides
    framesep=4pt,  % Margin size
    framerule=0pt
}

\title{Chesskell: Embedding a Two-Player Game in Haskell's type system}
\subtitle{3rd Year Project Progress Report}
\author{Toby Bailey}
\date{\today}

\begin{document}

\begin{titlepage}
    \maketitle
    \tableofcontents
\end{titlepage}

\section{Introduction}

In 2020, video games are more popular than ever. In the US alone, an ESA report\footnote{\url{https://www.theesa.com/wp-content/uploads/2020/07/Final-Edited-2020-ESA_Essential_facts.pdf}} estimates that there are more than 214 million individuals who play games. Considering this, it's surprising how many games are released with major bugs in their software---some of which end up being so notable that news and footage of them appear on mainstream media\footnote{\url{https://www.bbc.co.uk/news/technology-50156033}}.

As programming languages have evolved, many have begun to address errors at compile time. Features like optional types are being introduced to languages such as Java and C\#, and languages like Rust have pioneered ways of safely handling dynamic allocation through the use of owner types\footnote{\url{https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html}}. Many language compilers now force the developer to handle classes of errors that previously could only be encountered at runtime, such as null pointer exceptions.

However, the most common programming language used for game development is C++\cite{gamepp}, despite its' lack of safety and allowance of direct pointer arithmetic. C++ is chosen for its' speed, but as computers (and gaming consoles) get more powerful, runtime speed becomes less important than developer productivity. Research into bringing more type-safety into game programming environments is rare, and is the niche this project attempts to fill.

Recent versions of the \emph{Glasgow Haskell Compiler} (GHC) support programming at the type level, allowing programmers to compute with types in the same way that languages like C or Python compute with values\cite{yorgey2012giving}, using \emph{type families}\cite{opentfs}\cite{closedtfs} that emulate functions at the type-level. These computations run at compile time, before an executable of the source code is generated, allowing programmers to transform logic errors into type errors\cite{twt}.

The aim of this project is to demonstrate a proof-of-concept; that it is possible to model Chess at the type-level, and that compiled programs comply with the rules.

\section{Background}

The project, nicknamed Chesskell, has the main aim of modelling the classic board game Chess in Haskell's type system. This type-level model will be interacted with via a Haskell-embedded Domain-Specific Language (DSL), for describing games of chess. This Embedded DSL (EDSL) will be modelled on Algebraic Notation, a method of writing down the moves associated with a particular match of chess.

% In Haskell, values have types, and types have kinds. Types of kind \lstinline{*} (or \lstinline{Type}) have term-level values; \lstinline{Int} has kind \lstinline{*} because it has the inhabitants \lstinline{0}, \lstinline{1}, \lstinline{2}, etc. The \lstinline{-XDataKinds} extension allows the programmer to define other kinds\cite{yorgey2012giving}, but these kinds do not have any term-level values. We explain this with a more concrete example below, when relevant. Chesskell makes heavy use of these programmer-defined kinds.

% TODO: A nice diagram??

\subsection{Related Work}

There are many publicly available chess-related programs written in Haskell\footnote{\url{https://github.com/mlang/chessIO}}\footnote{\url{https://github.com/nionita/Barbarossa}}. Many of these are chess engines, which take in a board state and output the move(s) which are strongest, and so therefore performs move checking at the value-level to ensure that the moves that it outputs are valid. Chesskell differs from these in function, in that the end software will not output a list of strong moves; it will simply take in the moves performed, and state whether they are valid chess moves or not. We are not aware of any such type-level chess implementations in Haskell.

There have been allusions to chess at the type-level through solving the N-queens problem in dependently typed languages, such as Idris\footnote{\url{https://github.com/ExNexu/nqueens-idris}}\cite{idrisnqueens}. The N-queens problem makes use of some chess rules, including the Queen's attack positions (a straight line in any direction); but as the end goal is not to successfully model a game of chess, it is not a full type-level chess implementation.

Despite the apparent lack of work on Chess at the type level specifically, there is work on Haskell-Embedded DSLs in other domains to enforce certain behaviour at compile time. Mezzo\cite{mezzohaskellsymposium} is an EDSL for music composition, which checks if the created piece of music conforms to some musical ruleset before compilation of the program. WASH/CGI\cite{washcgi} is an EDSL for type-safe server-side web scripting, which ensures thread-safe server operations and valid XHTML generation.

\section{Project Functional Requirements}

\begin{enumerate}
    \item The system will contain a type-level model of chess, which will:
          \begin{enumerate}
              \item Support all rules within the FIDE official chess rules.
              \item Have an internal representation of the board, the pieces, and other information relevant to the state of play.
              \item Be able to detect when a rule of chess has been broken, and give out a compile-time error to explain which rule was broken and how.
          \end{enumerate}
    \item This type-level system will run on the Glasgow Haskell Compiler.
    \item This type-level system will be accessible via an Embedded Domain-Specific Language, which will:
          \begin{enumerate}
              \item Describe a game of chess, move by move.
              \item Be written in Haskell source files, and be valid Haskell according to the Haskell grammar.
              \item Be type-checked by the type-level model, and will cause errors if the game described breaks the established rules of chess.
          \end{enumerate}
\end{enumerate}

\section{Current Progress}

\subsection{Chess Types Overview}

The software has a full representation of a game of chess at the type-level, as we explain below. As the game is checked move by move, the only representation required is the board at the time of checking; containing all pieces on that board.

The most important types are the board, and the individual pieces on it. Both of these types are composed of other types, making them \emph{composite types}; the board is comprised of pieces, and the pieces contain that piece's team, name, and position.

\subsubsection{Team and PieceName}

Both of these types are simple algebraic data types, with all inhabitants defined in code. The team defines whether a piece is black or white, and the piece's name states which chess piece it is; a pawn, a rook, and so on.

The declarations below, combined with the \lstinline{-XDataKinds} extension, create two things. The first is a value-level representation of \lstinline{Team} and \lstinline{Piecename}, where \lstinline{Black} is a value of type \lstinline{Team}. The second is a \emph{type-level} representation, where \lstinline{'Black} is a type and \lstinline{Team} is a kind\footnote{Note that \lstinline{'Black} has no term-level values, since it does not have kind \lstinline{*}}.

% For values that have been promoted to types, a ' may be prefixed (as with \lstinline{'Black}) above. However, this prefix is optional, since GHC can, in most cases, tell whether something is a value or a type from context. Where unclear, this report will use the prefix to distinguish types from values.

\begin{lstlisting}
data Team = Black | White
data PieceName = Pawn
            | Bishop
            | Knight
            | Rook
            | King
            | Queen
\end{lstlisting}

\subsubsection{Position}

The type for holding a piece's position makes use of two more types, one for columns and the other for rows. In chess, columns are labelled with letters and rows are labelled with numbers; "a1" is the top-left of the board, and "h8" is the bottom-right. The column type is another simple algebraic data type with inhabitants listed. The row type is a type-level implementation of Peano natural numbers.

% The below definition makes use of \emph{Generalised Algebraic Data Type} syntax, or GADT syntax for short. This is an extension to Haskell, allowing programmers to define more complex data types by describing the types of its' type constructors. This is clear below: \lstinline{Z} is a value of type \lstinline{Nat}, while \lstinline{S} is a function that takes in a \lstinline{Nat} and returns another \lstinline{Nat}.

\begin{lstlisting}
data Column = A | B | C | D | E | F | G | H
data Nat where  -- Used for rows
    Z :: Nat
    S :: Nat -> Nat
\end{lstlisting}

The Position type itself is a \emph{product type}, a type whose cardinality\footnote{A type's cardinality is the number of inhabitants it has.} is equal to the product of the types it takes in. Since \lstinline{Position} takes in a type of cardinality 8 (\lstinline{Column}) and a type of infinite cardinality (\lstinline{Nat}), it has infinite cardinality, even though only 64 of them are valid chess positions.

% TODO: Chess board diagram??

\begin{lstlisting}
data Position where
    At :: Column -> Nat -> Position
\end{lstlisting}

\subsubsection{The Pieces}

Each piece contains information relevant for rule checking: that piece's team, name, and an information type. The information type contains a \lstinline{Nat} and a \lstinline{Position}, to represent the number of moves that piece has taken, and its current position on the board. Recording the number of moves the piece has taken is important for several rules in chess, including castling and \textit{En Passant}. As such, it's included in the \lstinline{PieceInfo} type.

The \lstinline{PieceInfo} type was created separate from the plain \lstinline{Piece} type so that if any further information needed adding, it could be with minimal issues (though no such additional information was required).

\begin{lstlisting}
-- Pieceinfo type, containing general information
data PieceInfo where
    Info :: Nat -> Position -> PieceInfo

-- Piece type, containing the key information for a piece
data Piece where
    MkPiece :: Team -> PieceName -> PieceInfo -> Piece
\end{lstlisting}

\subsubsection{The Board}

At the type level, the most common way of storing n elements is with the built-in list type (similar to the value-level). However, a singly-linked list has issues; how can we ensure that the chess board is the appropriate size without a length check each move? This would take at least 56 additions, since the length must be computed recursively; as well as 7 more addition operations to put together the list lengths.

Performing such a check each move would be wasteful. Instead, length-indexed vectors are used. \lstinline{Nat} values are used to specify the length of a vector, resulting in a type error if the vector is any other length. As with most things in Haskell, they are defined recursively; an empty vector has length 0, and you express a vector of length (n + 1) by pushing an element to the front of a vector of length n.

\begin{lstlisting}
data Vec (n :: Nat) (a :: Type) where
    VEnd   :: Vec Z a
    (:->)  :: a -> Vec n a -> Vec (S n) a
\end{lstlisting}

For example, a vector of 3 boolean types has the type: \lstinline{Vec (S (S (S Z))) Bool}. The board can be expressed using these vectors---a vector of 8 vectors of 8 pieces. (\lstinline{Maybe Piece} is used instead, since a board square does not necessary contain a piece.)

\begin{lstlisting}
type Eight = (S (S (S (S (S (S (S (S Z))))))))
type Row   = Vec Eight (Maybe Piece)  -- Row of eight Maybe Pieces
type Board = Vec Eight Row            -- Grid of eight rows
\end{lstlisting}

Although this is the main board type, it is augmented with a \lstinline{BoardDecorator}, so named because the intention is to be similar to the decorator design pattern\cite{decorator} (with the exception that subclassing and superclassing are not features of Haskell). \lstinline{BoardDecorator} should be used instead of \lstinline{Board}, since it provides additional information:

\begin{itemize}
    \item The last team to move;
    \item The last position moved to;
    \item The White and Black king positions, stored as a tuple;
    \item The number of moves in the game thus far.
\end{itemize}

This information prevents repeated passes over the \lstinline{Board} which existed in previous versions of the program, to find the king positions. While there is the overhead that the \lstinline{BoardDecorator} must be updated at each move, the code is much conceptually clearer with the use of the decorator.

\begin{lstlisting}
data BoardDecorator where
    Dec :: Board             -- Chess board
    -> Team                  -- Last team moved
    -> Position              -- Last position moved to
    -> (Position, Position)  -- King positions
    -> Nat                   -- No. of moves so far
    -> BoardDecorator
\end{lstlisting}

\subsection{Checking Chess Rules}

All of the rule-checking is performed by type families that take in the \lstinline{BoardDecorator} and output either a correct result, or a type error. Rule-checking occurs during movement, since the chess game effectively hangs while players do not move.

\subsubsection{Type families in Haskell}

Although Haskell allows type-level computation via type families, these type families must be fully saturated. That is, they can't be partially applied like normal Haskell functions can. However, Li-yao Xia's work on First Class Families\footnote{\url{https://github.com/Lysxia/first-class-families}} defines a kind of type-level interpreter, allowing similar behaviour to partial application.

This means that the board can be mapped over, performing computation on the pieces therein without writing a new function for each map. Incrementing a piece's move count, or changing the name of a piece, is therefore much easier with First Class Families than it would otherwise be with regular type families.

\subsubsection{Move Lists}

Each piece, depending on its team and name, can move to a certain number of spaces. For instance, a King can move a single space in any direction. The \lstinline{PieceMoveList} type family formalises this, returning a list of spaces that a piece can move to (given a piece and board decorator).

\begin{lstlisting}
data PieceMoveList :: Piece -> BoardDecorator -> Exp [Position]
-- If it's the pawn's first move (i.e. it has a move count of 0), allow it to move two spaces, otherwise move one
type instance Eval (PieceMoveList (MkPiece team Pawn info) boardDec) = Eval (If (Eval ((IsZero . GetMoveCount) info)) (PawnStartMove (MkPiece team Pawn info) boardDec) (PawnPostStart (MkPiece team Pawn info) boardDec))

-- Bishops move diagonally
type instance Eval (PieceMoveList (MkPiece team Bishop info) boardDec) = Eval (AllReachableDiag team boardDec (Eval (GetPosition info)))

-- Knights move in an L-shape
type instance Eval (PieceMoveList (MkPiece team Knight info) boardDec) = Eval (AllReachableGivenList team boardDec (Eval (GetAllKnightPositions (Eval (GetPosition info)))))

-- Rooks move in straight lines
type instance Eval (PieceMoveList (MkPiece team Rook info) boardDec) = Eval (AllReachableStraightLine team boardDec (Eval (GetPosition info)))

-- Queens can move in any direction
type instance Eval (PieceMoveList (MkPiece team Queen info) boardDec) = Eval (AllReachableLineAndDiag team boardDec (Eval (GetPosition info)))

-- Kings can move a single space in any direction
type instance Eval (PieceMoveList (MkPiece team King info) boardDec) = KingMoveList (MkPiece team King info) boardDec
\end{lstlisting}

There is another function, \lstinline{PieceAttackList}, which is similar to \lstinline{PieceMoveList} but gives the list of spaces that a piece can attack. This is different from a piece's move list in a handful of cases (for instance, pieces can attack the opposite team's King, but cannot move to its position and take it).

\subsubsection{Moving the Pieces}

The core movement function, aptly named \lstinline{Move}, performs a series of checks on the board state, moves the piece, and then performs further checks. The actual movement code is omitted here for brevity; but all moves except for pawn promotion are complete.

\begin{lstlisting}
-- MoveNoChecks moves the piece depending on its' type,
-- handling any relevant side effects
data Move :: Position -> Position -> BoardDecorator -> Exp BoardDecorator
type instance Eval (Move fromPos toPos boardDec) = Eval ((
    CheckNoCheck (GetMovingTeam boardDec) . -- Post-move checks
    MoveNoChecks fromPos toPos .            -- Move the piece
        NotTakingKingCheck toPos .          -- Pre-move checks
        CanMoveCheck fromPos toPos .
        NotTakingOwnTeamCheck toPos .
        NotSamePosCheck fromPos toPos .
        NotLastToMoveCheck fromPos .
        TeamCheck fromPos) boardDec)
\end{lstlisting}

\subsection{EDSL}

\subsubsection{Proxies and Singletons}

Type-level information is not naturally available to Haskell's term-level facilities, due to type erasure. As such, there are various methods to simulate computation with types at runtime.

Proxy types are parameterised with kind-polymorphic type variables\cite{yorgey2012giving}. A \lstinline{Proxy} value can have type \lstinline{Proxy Int} or \lstinline{Proxy 'Black}, for example. Proxies are used to make runtime board decorator information available at the type level in Chesskell.

Singleton types mimic dependent types\cite{singletons}; each type has a single, unambiguous value, and vice versa. This value can be used to pass around type information at the term-level. Chesskell uses singletons to perform computation with positions and piece names.

\subsubsection{EDSL Implementation}

The EDSL is implemented through a Continuation Passing Style\cite{cps} scheme, with inspiration taken from the Flat Builders pattern developed by Dmitrij Szamozvancev\cite{mezzo}. The core idea is that a value is transformed via a series of continuation functions, until the final continuation function returns a value.

\begin{lstlisting}
-- Starts with a value of type t, gets a continuation of type (t -> m), and applies it to the value
type Spec t = forall m. (t -> m) -> m

-- Converts a value of type s into a value of type t, passing that t-value into a continuation
type Conv s t = s -> Spec t

-- Ends the continuation stream
type Term t r = t -> r
\end{lstlisting}

Type-level computations within the EDSL are achieved through \emph{type applications}\cite{typeapplication}, which allow the programmer to specify the exact type of a kind-polymorphic type variable. Using a combination of singletons, proxies, kind signatures, and type applications, the value-level Haskell code for the EDSL can have specific type variables and involve type family application. Essentially, the term-level EDSL can involve type-level rule checking.

The chess game starts with a \lstinline{Proxy} value, with its type containing a \lstinline{BoardDecorator} type. Continuations are passed, transforming that value, until the chess game ends (or a rule is broken). The core continuations defined are named after the pieces, such as \lstinline{pawn} and \lstinline{king}. Each of them takes in an \lstinline{SPosition}, a singleton version of \lstinline{Position}. A new datatype, \lstinline{MoveArgs}, is defined in order to simplify the process of passing information between the continuations.

\begin{lstlisting}
-- StartDec is a board decorator holding all the information for the start of a chess game
chess :: Spec (Proxy StartDec)
chess cont = cont (Proxy @StartDec)

data MoveArgs where
    MA :: BoardDecorator -> Position -> PieceName -> Position -> MoveArgs

-- Passes a created MoveArgs type constructor to the continuation
pawn :: Proxy (b :: BoardDecorator) -> SPosition fromPos -> Spec (Proxy (MA b fromPos 'Pawn))
pawn (dec :: Proxy b) (from :: SPosition fromPos) cont = cont (Proxy @(MA b fromPos Pawn))
\end{lstlisting}

The next continuation, \lstinline{to}, takes in another \lstinline{SPosition}, performs the move computation, puts the resulting board decorator into a \lstinline{Proxy} type, and passes that \lstinline{Proxy} into the continuation given.

\begin{lstlisting}
-- Moves a piece from one position to another
to :: Proxy (MA (b :: BoardDecorator) (fromPos :: Position) (n :: PieceName)) -> SPosition toPos -> Spec (Proxy (Eval (MoveWithStateCheck n fromPos toPos b)))
to (args :: Proxy (MA (b :: BoardDecorator) (fromPos :: Position) (n :: PieceName))) (to' :: SPosition toPos) cont = cont (Proxy @(Eval (MoveWithStateCheck n fromPos toPos b)))
\end{lstlisting}

The final relevant definition is of \lstinline{end}, which ends the chess game (and the continuation stream).

\begin{lstlisting}
end :: Term (Proxy (b :: BoardDecorator)) (Proxy (b :: BoardDecorator))
end = id
\end{lstlisting}

Using the above continuations, we can lay out a chess game, move by move. Consider a short game, involving a 3-move checkmate by White. The game can be laid out as below in the EDSL, and will compile successfully:

\begin{lstlisting}
-- Describes a game with a checkmate by White in 3 moves
game = chess
           pawn _e2 to _e4   -- White begins
           pawn _f7 to _f5   -- Black move
           queen _d1 to _f3
           pawn _g7 to _g5
           queen _f3 to _h5  -- Checkmate!
       end
\end{lstlisting}

However, should Black attempt to move after checkmate, an error will be logged, since no moves by Black will be valid:

\begin{lstlisting}
-- Below results in a type error:
    -- * The Black King is in check after a Black move. This is not allowed.
    -- * When checking the inferred type
    --     game :: Data.Proxy.Proxy (TypeError ...)
game = chess
           pawn _e2 to _e4   -- White begins
           pawn _f7 to _f5   -- Black move
           queen _d1 to _f3
           pawn _g7 to _g5
           queen _f3 to _h5  -- Checkmate!
           pawn _g5 to _g4   -- Invalid move by black - Black King is in checkmate
       end
\end{lstlisting}

Or, should White attempt an impossible move in the middle of the game, such as moving a Queen through another piece, a different type error will occur:

\begin{lstlisting}
-- Below results in a type error:
    -- * There is no valid move from D1 to D3.
    -- The Queen at D1 can move to: E2, F3, G4, H5
    -- * When checking the inferred type
    -- game :: Data.Proxy.Proxy (...)
game = chess
           pawn _e2 to _e4   -- White begins
           pawn _f7 to _f5   -- Black move
           queen _d1 to _d3  -- White Queen moves through a Pawn - not allowed
           pawn _g7 to _g5
           queen _f3 to _h5  -- Checkmate!
       end
\end{lstlisting}

\subsubsection{EDSL Board Creation}

There are additional statements to help create an initial chess board for easy testing. A short example is below:

\begin{lstlisting}
-- A simple example board created for testing castling code
example
  = create                 -- create chess board
        put _Wh _R at _a8  -- Set a white rook at a8
        put _Wh _R at _h1
        put _Bl _P at _h7  -- Set a black rook at h7
        lastTeam _Bl       -- Set black as last team moved
    startMoves             -- Begin chess game
        rook _a8 to _a2
        pawn _h7 to _h6
        rook _h1 to _h2
    end
\end{lstlisting}

\subsubsection{Pawn Promotion}

The EDSL function \lstinline{becomes} handles Pawn promotion, transforming a Pawn into another piece after it has moved. Since the whole chess game is expressed in continuation-passing style, \lstinline{becomes} simply edits a Pawn's \lstinline{PieceName} in place.

\begin{lstlisting}
game = chess
           -- ...
           pawn _a7 to _a8 becomes _Queen
           -- ...
       end
\end{lstlisting}

This can be combined with the board creation statements to create a simple game which compiles:

\begin{lstlisting}
game = create
           put _Wh _P at _a7
       startMoves
           pawn _a7 to _a8 becomes _Queen
       end
\end{lstlisting}

However, the below code will also compile, when it should not, since according to the FIDE 2018 Laws of Chess\footnote{\url{https://handbook.fide.com/chapter/E012018}}, promotion is not optional, and must occur.

\begin{lstlisting}
game = create
            put _Wh _P at _a7
        startMoves
            pawn _a7 to _a8  -- No promotion - type error
        end
\end{lstlisting}

\subsubsection{EDSL Issues}

Early versions of the EDSL crashed GHC, due to the initial definition of \lstinline{chess}; the programmer did not manually create \lstinline{StartDec}, but pieced it together through a series of type family applications:

\begin{lstlisting}
chess :: Spec (Proxy StartDec)
chess cont = cont (Proxy :: Proxy StartDec)
\end{lstlisting}

GHC would run out of memory to allocate, and would either crash or hang for multiple minutes. This behaviour is unusual, and so we filed a GHC bug report\footnote{\url{https://gitlab.haskell.org/ghc/ghc/-/issues/18902}}. As a work-around until the bug is fixed, \lstinline{StartDec} was manually written out in full in the source Haskell file.

Additionally, adding the move number to the type error\footnote{e.g. \lstinline{Error at move 1: Pawn cannot move to...}} causes a spike in compile time; not as excessive as above, as GHC does not crash, but still doubling or tripling compile time. The move number will only be re-added to the error if this problem can be fixed or worked around, since it would greatly slow the testing of a large number of games.

\subsection{Testing}

The test suite is a mixture of HSpec behaviour-driven tests\cite{hspec} and module declarations. The original plan was to have all tests be HSpec tests; many of these HSpec tests make use of the type-level testing facilities laid out in other works\cite{mezzo}. However, running the test suite causes excessive memory usage, exceeding 27 GB in some cases.

Work on a solution is ongoing, but for now, many tests for the EDSL's new features are expressed as high-level declarations in a Haskell module. The tests are run by seeing whether these declarations compile or not (and if not, what error they throw). This will hopefully only be temporary, but it should suffice as a rudimentary (if slow) method of integration testing.

\section{Next Steps}

As the project's main feature set is nearly complete, the remaining time will be spent testing, evaluating, and improving the project. Full-length chess games will be expressed in the EDSL, to determine if the program compiles correct chess games; and the subtle errors will be introduced to those games, to test that incorrect games fail to compile. Of course, the code itself is only part of the project; work on the dissertation should begin early next term/year.

\subsection{Chess Rules}

At the moment, the only incomplete chess rule is \emph{mandatory promotion}. Promotion in the EDSL is optional, meaning a Pawn can reach the opposite end of the board and remain a Pawn. The current implementation of promotion does not involve the \lstinline{Move} function, but since the pawn must be promoted at the end of its' move, the \lstinline{Move} function needs to include this functionality.

\subsection{EDSL}

The only major addition to the EDSL is mandatory promotion, as we explain above. However, a few additional helper functions or syntax changes may be helpful during development, and so the EDSL is subject to change.

\subsection{Performance}

The current memory usage and compile time of the EDSL is acceptable, but only short ($<$10 moves) chess games have been described and tested thus far. Memory usage and compile time are likely to rise both with the length of the chess game, and the number of games tested. Memory usage optimisations may become necessary as testing continues.

\subsection{Revised Timetable/Plan}

\subsubsection{Weeks 9-10: 30th November to 13th December}

These two weeks will be spent implementing mandatory promotion, and performing integration/system testing. A curated data set of chess games will be expressed in the EDSL and put through the GHC compiler. Some of these games will be valid, and some will be invalid. Only valid games should compile, and invalid games should fail to compile with an appropriate type error.

\subsubsection{Weeks 11-14: 14th December 2020 to 10th January 2021}

This is the first section of allocated empty space. If the test suite is posing any issues (with regards to compile time and memory usage) then this additional month should help with solving them. But should the testing be going well, with promotion complete, then this extra time will be spent either starting early on the dissertation, or adding extensions to the project to further explore the modelling of games at the type-level.

\subsubsection{Weeks 15-18: 11th January to 7th February}

Writing the dissertation is planned for this stretch of time; it will be planned out, section by section, with any relevant graphs, figures, and citations gathered.

The module CS324 Computer Graphics has a coursework due on the 20th January; as such, planning the dissertation could take longer than expected. However, since a month is set aside for just planning, delays are unlikely.

\subsubsection{Weeks 19-22: 8th February to 7th March}

Once the previous detailed planning stage is complete, writing shall begin; with a detailed enough plan, this section should not take longer than a month. An initial draft will be completed by the 7th of March.

The project itself will be evaluated during this period, examined for any subtle bugs, and the code will be cleaned up and completed. Work on the project presentation will also start in earnest, writing out a script.

\subsubsection{Weeks 23-24: 8th March to 21st March}

These two weeks are more empty space; set aside to act as a buffer for delays in dissertation writing. The project presentation is expected on the 19th March; so this empty space will ideally be spent completing the presentation and rehearsing it.

\subsubsection{Weeks 25-29: 22nd March to 25th April}

Drafting, re-drafting, and refining the dissertation (with the help of the supervisor) will take place during this time. This is the final stretch, and will be spent ensuring that the final piece of writing is as good as it can be.

Revision for examinations is key during this period; however, since the dissertation should be complete and this period is for evaluation and not the main bulk of writing, there should be ample time.

\section{Resources, Risks, and Ethical Considerations}

\subsection{Resources}

Developing this program requires a computer (and Operating System) which can run the latest version of GHC (8.10.2, at the time of writing). GHC runs on most Linux distributions, as well as Windows and MacOS. In other words, it runs on almost all consumer-grade PCs, and so suitable development and testing hardware is plenty.

\subsection{Risks}

The biggest risk going into the project was that it was unachievable; however, that risk has not materialised---the implementation is almost complete. The largest project-related risks left are the memory usage and compile time issues. 

There are, of course, other risks not directly associated with the project; in 2020, there is a large-scale pandemic going on, which could pose considerable personal risk. However, by following Government and University guidelines, the chances of contracting COVID-19 will be kept to a minimum, and the project should not be interrupted by sudden illness.

\subsection{Legal, Professional, and Ethical Considerations}

As this project is undertaken alone, with no involvement from third parties (aside from the project supervisor), there are no additional legal, professional, or ethical considerations to consider. The program contains no personal data processing, and such processing will not be introduced.

\bibliographystyle{ieeetr}

\bibliography{progress}

\end{document}