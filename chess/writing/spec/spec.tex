\documentclass[12pt, a4paper]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}

\title{Chesskell: Embedding a Two-Player Game in Haskell's type system}
\subtitle{3rd Year Project Specification}
\author{Toby Bailey}
\date{\today}

\begin{document}

\begin{titlepage}
    \maketitle
    \tableofcontents
\end{titlepage}

\section{Introduction}

In 2020, video games are more popular than ever. In the US alone, an ESA report \footnote{\url{https://www.theesa.com/wp-content/uploads/2020/07/Final-Edited-2020-ESA_Essential_facts.pdf}} estimates that there are above 214 million individuals who play games. Considering this, it's surprising how many games are released with major bugs in their software---some of which end up being so notable that news and footage of them appear on mainstream media, such as BBC News \footnote{\url{https://www.bbc.co.uk/news/technology-50156033}}.

In recent years however, programming languages have evolved to address runtime bugs at compile time. Features like optional types are being introduced to languages such as Java and C\#, and languages like Rust have pioneered ways of safely handling dynamic allocation through the use of owner types.

% TODO: Put citations for the above??

Haskell, in recent \emph{Glasgow Haskell Compiler} (GHC) versions, has supported programming at the type level, allowing programmers to compute with types in the same way that languages like C or Python compute with values. Type-level computations are run at compile time, before an executable of the source code is generated. This type-level toolbox allows programmers to transform business logic errors into type errors---and this style of programming would enable game developers to eliminate many kinds of runtime problems in their games.

The aim of this project is to demonstrate a proof-of-concept; that it is possible to model games at the type-level, and ensure that programs can only be compiled when they follow the rules of the game.

\section{Problem Statement}

The project, named Chesskell, has the main aim of modelling the classic board game Chess in Haskell's type system. Chess is a complex logic-based game, with many moving parts, which contains move that can have side-effects (for instance, moving a Pawn to the opposite side of the board transforms that Pawn into a Queen).

Chess is for two players/teams, who are denoted Black and White after the colour of their numerous pieces, who act in alternating turns until one wins the game. A player cannot choose inaction for their turn; they must move one of their pieces, if they can. A player wins by putting the opposing team's "King" piece in a position whereby all moves it could make would put it in the direct path of another piece. All pieces have a certain area that they can "take" within, enabling them to remove other pieces from play. (For instance, Rook/Castle pieces can take any piece of the opposite team which is in the same horizontal or vertical axis on the board, with no other pieces in the way.)

The term "game" is rather loose, and encompasses many physical actions and software programs. Chess is complex, has a win condition, and involves multiple players; modelling it at the type-level is a challenge, and would prove that type-level computation is fit for eliminating certain errors in video games.

This type-level model will be interacted with via a Haskell-embedded Domain-Specific Language (DSL), for describing games of chess. This Embedded DSL (EDSL) will be modelled on Algebraic Notation, a method of writing down the moves associated with a particular match of chess.

The resulting program will take in as input a Haskell source file, describing one (or more) matches of chess in the EDSL. This file will be compiled, and in doing so, the type-level model of chess will be compared against the game described by the EDSL, and the compilation will fail if the described game breaks the International Chess Federation (FIDE) rules of chess.

The success of this project will be gauged against a data set of chess games, expressed via the EDSL; many of which will be incorrect and break the rules of chess in one way or another. The final program must successfully compile the games which do not break the rules, and must fail to compile those which break them.

\section{Project Requirements}

% TODO: Break aim of project into several smaller objectives
% Clear, achievable subgoals - use MoSCoW? Requirements??

\subsection{Formal Requirements}

The below list splits the requirements into \emph{Functional} and \emph{Non-Functional} requirements, employing the MoSCoW system to explain the scope of the project.

% TODO: Requirements list

\section{Methodology}

% TODO: Lay out how best to achieve the above objectives

\subsection{Software Development Methodology}

\subsection{Evaluation and Testing}

As noted earlier, the final project's success will be evaluated against a curated data set of chess games. However, binary success is not the only helpful metric; the final project must compile within a reasonable time, and must output helpful errors that explain the chess rule which was broken, in the case of failure.

Compiling within a "reasonable time" is nebulous; if the program compiles within 5 minutes on a consumer-grade laptop, then it will be enough. Additionally, the errors must specify the exact move which breaks the rule, which piece broke it, and the way in which the rule was broken.

For example, "Error - broken rule" is unacceptable, and should be replaced with something more akin to the following:

\begin{lstlisting}
Error on move 6:
    Black Pawn has moved to d4, but it can only move to: d5, d6.
\end{lstlisting}

Of course, the specific error and relevant information will depend on the exact rule broken; but error messages which point to the exact transgression are \emph{always} helpful.

\section{Timetable/Plan}

% TODO: Follow MG's advice and get that timetable going in 2 week chunks. Maybe a nice graph? Ask BL.

\section{Resources, Risks, and Ethical Considerations}

\subsection{Resources}

\subsection{Risks}

The biggest risk with this project is that it is unachievable. Haskell's type-level computations are limited in scope, and other languages (such as Idris) have fully dependent types and so can express things at the type-level that Haskell may simply not be able to yet.

Should this be the case, I will attempt the project in a fully dependently-typed language, such as Idris; and if even that should fail, then there will be lots of work done on implementing a two-player game at the type-level, and will surely be a specific reason as to why it is impossible. Future research could then build on this foundation, attempting to find ways around this individual problem.

There are, of course, other risks not associated with the project; in 2020, there is a large-scale pandemic going on, which could pose considerable personal risk. However, by following Government and University guidelines, the chances of contracting COVID-19 will be kept to a minimum, and hopefully the project will not be interrupted by sudden illness.

Planning out the project, as above, to account for other deadlines and busy periods during University life should also help mitigate the risk of delaying the project.

\subsection{Ethical Considerations}

As this project is undertaken alone, with no involvement from third parties (aside from the project supervisor), there are no additional legal, professional, or ethical considerations to consider. There will be no personal data processing, and no pre-existing Haskell type-level chess implementation to plagiarise.

\end{document}