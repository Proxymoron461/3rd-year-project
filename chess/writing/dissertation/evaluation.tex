\chapter{Evaluation}

In this chapter, we evaluate Chesskell in the context of both Haskell and other Chess notations. Additionally, we describe the testing process used to ensure Chesskell meets its specification.

\section{Testing} \label{testsection}

One of the priorities during development was a robust testing procedure. We explain below the various methods of testing employed, including details on how these tests were conceived.

\subsection{Type-level Unit Testing} \label{reflsection}

Usually, unit tests exist to model dynamic behaviour; to check whether running code can perform (or fail to perform) specific operations. However, in Chesskell, the runtime behaviour is very minimal, as all Chess rules are enforced statically through the types. One method of unit testing this static behaviour would be to put definitions into a file, and see if they compile; and indeed, some of the Chesskell tests are carried out in this manner (see \cref{gametestsection}). But this method is unwieldy, and using one of Haskell's pre-existing testing frameworks allows quicker testing and a clearer view of the results of the test suite.

One way of dynamically asserting some static behaviour is to use GHC \emph{deferred type errors}~\cite{deferredtypeerrors}, by which type errors occur as runtime exceptions (i.e. as values of type \inline{TypeError}) whenever a value which causes a type error is evaluated. These runtime exceptions can be pattern-matched on, allowing value-level code to check if an exception generated by a given code snippet is a type error.

Two assertions by other authors are used in Chesskell to craft unit tests for types in this manner: \inline{shouldTypecheck}, defined in the Mezzo library\footnote{\url{https://hackage.haskell.org/package/mezzo}}, and \inline{shouldNotTypecheck}, an HSpec library\footnote{\url{https://hackage.haskell.org/package/should-not-typecheck}}. These assertions pass or fail depending on whether a given expression, when evaluated, generates a deferred type error or not.

For instance, \inline{shouldTypecheck (2 == 3)} should pass, since even though \inline{2} is not equal to \inline{3}, checking for equality between two numbers in this manner is well-typed. However, \inline{shouldTypecheck (not 5)} should fail, since the function \inline{not} has type \inline{Bool -> Bool}, and the value \inline{5} cannot have the type \inline{Bool}.

We use Haskell's HSpec library, for behaviour-driven testing~\cite{hspec}, to create many unit tests with which to test the project. Most commonly, we employ these individual unit tests to test the behaviour of individual type families and First Class Families, such as in the example we give below:

\begin{lstlisting}
oppositeTeamTest :: White :~: Eval (OppositeTeam Black)
oppositeTeamTest = Refl
-- ...
shouldTypecheck oppositeTeamTest
\end{lstlisting}

Note the use of the \inline{(:~:)} type in the above test; this type is defined in \inline{Data.Type.Equality}, and is used as a value-level proof of type equality. It has a single value, \inline{Refl}, with type \inline{a :~: a}. In other words, if you define a \inline{Refl} value with the type \inline{t1 :~: t2} for some types \inline{t1} and \inline{t2}, then this definition will only type check if \inline{t1 ~ t2}; that is, if they can unify. Above, we can see this put to use -- the \inline{Refl} value with type \inline{White :~: Eval (OppositeTeam Black)} will produce a type error if the opposite team of Black is not White. We use the \inline{(:~:)} type often in Chesskell unit tests, as it provides a simple way of asserting that two types are equal.

\subsubsection{Scenario Testing} \label{scenariosection}

The behaviour of many of the type families in Chesskell depends on the current board state. As an example, consider Pawn movement; the valid moves for a Pawn vary based on whether it is that Pawn's first move, on the pieces around the Pawn, and on the last move made. To test corner cases, we construct test boards which should bring about specific behaviour in the type families tested, perhaps even causing those type families to generate a type error. During development, this manner of testing was nicknamed "Scenario Testing", and it shall henceforth be referred to as such.

For instance, both team's Kings should always be on the board. To have a King absent from one of the teams should result in undefined behaviour, as such an event signals a clear departure from the rules of Chess. To test this behaviour, we create a unit test on an empty board (which will naturally be missing both Kings), and ensure that failing to find the King of a specific team on that board results in type error:

\begin{lstlisting}
findKingTest :: Proxy (a :: Piece)
findKingTest = Proxy @(Eval (FindKing White EmptyDec))
-- ...
shouldNotTypecheck findKingTest
\end{lstlisting}

Note that the \inline{(:~:)} type we use in \cref{reflsection} is not used here; instead, we define the test with a \inline{Proxy a} type. Since we are expecting the above type variable \inline{a} to fail unification with a type error, there is no need to compare \inline{a} with any other type. We use \inline{Proxy} types rather than \inline{(:~:)} types when equality testing is not required, such as in cases where we expect a test to generate a type error.

For a more involved example of the unit testing process, consider Castling (a Chess move we detail in \cref{castlesection}). There are situations in which a team can castle in one direction, but not in the other direction; and in those situations, calling \inline{CanCastle} for that team should return \inline{True} for the valid direction, and \inline{False} for the invalid one. To test this behaviour, we create a custom Chess board (see \cref{castleboard} for a visual representation) named \inline{CastleDec}, in which the Black King can castle left but not right, and the White King can castle right but not left. We pair this custom board with two unit tests, to ensure that \inline{CanCastle} has the expected behaviour:

\begin{lstlisting}
canCastleBlackTest :: '(True, False) :~: CanCastle Black CastleDec
canCastleBlackTest = Refl

canCastleWhiteTest :: '(False, True) :~: CanCastle White CastleDec
canCastleWhiteTest = Refl
-- ...
shouldTypecheck canCastleBlackTest
shouldTypecheck canCastleWhiteTest
\end{lstlisting}

\begin{figure}
    \centering
    \fenboard{r3k1pr/8/8/8/8/8/8/RP2K2R w - - 0 1}
    \showboard
    \caption{A board where the Black King can castle left but not right, and the White King can castle right but not left.}
    \label{castleboard}
\end{figure}

\subsubsection{FIDE Laws of Chess Unit Tests}

To ensure correctness as far as possible, we create unit and scenario tests for each FIDE Law of Chess which is amenable to testing in this manner. One of the primary aims of Chesskell, as we state in \cref{introobjectives}, was to implement all FIDE laws concerning the game of Chess itself. An appropriate way of determining the success of this objective is to test as many laws of Chess as possible, to ensure that Chesskell's behaviour matches that of the FIDE ruleset.

As an example, consider the FIDE law outlining how Knights move around the board:

\begin{quoting}
    The knight may move to one of the squares nearest to that on which it stands but not on the same rank, file or diagonal.
\end{quoting}

To test this behaviour, we write a total of 16 unit tests. For both teams, eight tests encompassing movement in the four cardinal directions, as well as the four intercardinal ones. This movement is tested on boards which only contain the relevant Knight, and the two Kings (to avoid the "missing King" error we detail in \cref{scenariosection}). While these tests do not inspect every possible target and destination square, they give reasonable assurances that Knights move correctly around the board:

\begin{lstlisting}
whiteCannotGoLeft :: Proxy (a :: BoardDecorator)
whiteCannotGoLeft = Proxy @(Eval (Move (At D Nat5) (At B Nat5) WhiteKnightDec))

whiteCannotGoRight :: Proxy (a :: BoardDecorator)
whiteCannotGoRight = Proxy @(Eval (Move (At D Nat5) (At E Nat5) WhiteKnightDec))

-- ...

blackCannotGoNW :: Proxy (a :: BoardDecorator)
blackCannotGoNW = Proxy @(Eval (Move (At D Nat5) (At B Nat7) BlackKnightDec))

blackCannotGoNE :: Proxy (a :: BoardDecorator)
blackCannotGoNE = Proxy @(Eval (Move (At D Nat5) (At F Nat7) BlackKnightDec))
\end{lstlisting}

None of these tests should type check, as they involve invalid movement; so we use the \inline{shouldNotTypecheck} assertion:

\begin{lstlisting}
shouldNotTypecheck whiteCannotGoLeft
-- ...
shouldNotTypecheck blackCannotGoNE
\end{lstlisting}

\subsection{Chesskell Game Tests} \label{gametestsection}

To test Chesskell EDSL correctness, we use a similar process to the one we lay out in \cref{scenariosection}. We describe specific Chess scenarios (as plain Haskell source definitions) which should display certain behaviour, and manually ensure that the EDSL either compiles, or fails to compile with a specific type error. To illustrate, we give an example below. As we discuss in \cref{promotionsection}, Pawn promotion is mandatory, and it breaks the rules of Chess if a Pawn reaches the opposite end of the board and is not promoted. To test this, we create a custom Chess board and describe a Chess game in which a Pawn should have been promoted, but has not been. We then compile this described game, ensuring that GHC generates the expected type error:

\begin{lstlisting}
-- Below fails with the following type error:
-- * Promotion should have occurred at: h8. Pawns must be promoted when they reach the opposite end of the board.
-- * When checking the inferred type:
--     didntPromote :: Data.Proxy.Proxy (TypeError ...)
didntPromote = create
        put _Wh _P at h7
        put _Bl _P at a2
    startMoves
        pawn h7 to h8
    end
\end{lstlisting}

Additionally, we express the first few moves of a variety of famous Chess games in Chesskell notation, to ensure that Chesskell also compiles error-free Chess games. For instance, the first few moves of 20 famous Gary Kasparov games have been expressed in Chesskell notation and compiled, to test Chesskell's capabilities.

To add to the previous test suite, we replicate some of the games present, while introducing minor errors. For instance, consider the first 10 moves of the famous game between Loop and Deep Gandalf, two Chess AIs, which (as a Haskell source definition) GHC successfully compiles:

\begin{lstlisting}
loopVsGandalf = chess
        p e4 p c5
        n f3 p d6
        p d4 p d4
        n d4 n f6
        n c3 p a6
    end
\end{lstlisting}

With a separate definition, we recreate this game with a subtle error -- move 10 has been modified to ensure that the Pawn's destination square is the same as its origin square, a move disallowed in Chess:

\begin{lstlisting}
loopVsGandalfError = chess
        p e4 p c5
        n f3 p d6
        p d4 p d4
        n d4 n f6
        n c3 p a7  -- Pawn moves to same place!
    end
\end{lstlisting}

As expected, the error-free version compiles, and the erroneous version fails to compile.

\section{Compile Time and Memory Usage} \label{problemsection}

Key observations for us while developing Chesskell have been unpredictable compile-time and memory usage. While the extensions to Haskell's type system as implemented in GHC are very exciting and, as demonstrated, allow us to implement complex rule systems, it is difficult to debug them -- GHC's performance with respect to type-level computation is opaque to developers. In this section we outline the issues we faced, and describe approaches we found to solve or avoid them.

As we explain above in \cref{testsection}, the Chesskell library is accompanied by an extensive test suite, implemented using HSpec behaviour-driven tests~\cite{hspec} and deferrable type errors to test the outputs of type families adhere to the FIDE ruleset. Compiling this test suite causes GHC memory usage to exceed 27 GB. These memory issues are not specific to the tests, and can be reproduced in longer Chesskell games. Due to these issues, Chesskell games are practically limited to 12 moves before GHC crashes and runs out of memory (on all systems tested), although there is no theoretical limit to the number of moves.

Below, when we state that a Chesskell game takes $n$ seconds to compile, we mean that it takes $n$ seconds to compile the Chesskell description of the 1964/65 USSR Championship game between Ratmir Kholmov and David Bronstein. We chose this game as the benchmark for compile-time comparison, though others are also used to test the functionality of Chesskell (as we mention in \cref{gametestsection}).

\subsection{Finger Trees} \label{fingertreesection}

A common operation in Chesskell is creating lists of potential positions (i.e. move lists and attack lists), and combining them with the append \inline{(++)} operator. However, as we mention in \cref{fingertreedesign}, appending singly-linked lists takes $\mathcal{O}(n)$ time. Since this operation is common, we implemented type-level 2-3 Finger trees~\cite{fingertrees} to take advantage of better amortized append:

\begin{lstlisting}
data FingerTree (a :: Type) where
    Empty  :: FingerTree a
    Single :: a -> FingerTree a
    Deep   :: Digit a -> FingerTree (Node a) 
           -> Digit a -> FingerTree a

data Node a = Node2 a a | Node3 a a a
data Digit a = One a | Two a a | Three a a a | Four a a a a
\end{lstlisting}

We define operations to append both to the start and to the end of the tree as type families, denoted as \inline{:<} and \inline{:>} respectively. We give the definition of \inline(:>) below:

\begin{lstlisting}
type family (:>) (n :: FingerTree a) (x :: a) :: FingerTree a where
    Empty                           :> x
        = Single x
    Single y                        :> x
        = Deep (One y) Empty (One x)
    Deep left middle (One y)        :> x
        = Deep left middle (Two y x)
    Deep left middle (Two y z)      :> x
        = Deep left middle (Three y z x)
    Deep left middle (Three y z w)  :> x
        = Deep left middle (Four y z w x)
    Deep left middle (Four y z w a) :> x
        = Deep left (middle :> Node3 y z w) (Two a x)
\end{lstlisting}

Additionally, we show parts of the definition for an append operation, given as an open type family \inline{(++)}:

\begin{lstlisting}
type instance ((Deep leftL leftM leftR) ++ (Deep rightL rightM rightR))
    = Deep leftL (AddTree1Digit leftM (ToNode leftR rightL) rightM) rightR
-- ...

type family AddTree1Digit (t1 :: FingerTree a)
                          (d1 :: Digit a)
                          (t2 :: FingerTree a)
                          :: FingerTree a where
    AddTree1Digit Empty dig rightTree
        = AddDigitLeft dig rightTree
    AddTree1Digit (Single x) dig rightTree
        = x :< AddDigitLeft dig rightTree
    -- ...
    AddTree1Digit (Deep leftL leftM leftR) dig (Deep rightL rightM rightR)
        = Deep leftL (AddTree1Digit leftM (ToNode leftR rightL) rightM) rightR
\end{lstlisting}

We replaced all append and mapping operations over lists with corresponding operations on Finger Trees. To our disappointment, changes were negligible: compile time went down by an average of 5 seconds and memory usage was reduced by an average of 0.5 GB. Although this is an improvement, it again shows that algorithmic complexity is not responsible for the compiler performance we observe.

\subsection{Checking for Check}

One of the most complex parts of Chesskell involves detecting when a King is placed in check. As we explain in \cref{checksection}, an initial na\"ive implementation of testing for check (named \inline{CheckNoCheck}) involved assembling all possible moves by pieces of the opposite team, and checking if the King position was in that list. The pre- and post-move checks were composed together within a single family, along with the actual movement of the pieces themselves, like so:

\begin{lstlisting}
data Move :: Position -> Position
          -> BoardDecorator -> Exp BoardDecorator
type instance Eval (Move fromPos toPos boardDec) = Eval ((
    ShouldHavePromotedCheck toPos . CheckNoCheck .  -- Post-move checks
    MoveNoChecks fromPos toPos .
        CanMoveCheck fromPos toPos .  -- Pre-move checks
        NotTakingKingCheck toPos .
        NotTakingOwnTeamCheck toPos .
        NotSamePosCheck fromPos toPos .
        NotLastToMoveCheck fromPos .
        TeamCheck fromPos) boardDec)
\end{lstlisting}

Removing the \inline{CheckNoCheck} post-move check entirely (from the codebase using the old implementation) reduced memory usage of an 8-move Chesskell game from 22-23GB to 7.5-8GB, and average compile time from 1 minute 37 seconds to 24 seconds, proving that testing for check was a performance bottleneck.

Attempting to optimise the codebase and reduce memory usage as the result of an ``out of memory'' crash, we created the new ray implementation \cref{checksection}. Despite the reduced computation performed by GHC with the new implementation, there was no noticeable decrease in memory usage when compiling Chesskell games -- GHC continued to run out of memory and crash.

However, splitting out the pre-move rule checks and the post-move rule checks into separate type families helped GHC to terminate, no longer running out of memory. The new implementation (which we give below) takes less than 1 minute and 30 seconds to compile, and uses an average of 25GB of memory. We put the pre-move checks into a new \inline{MoveWithPreChecks} family:

\begin{lstlisting}
data MoveWithPreChecks :: Position
                       -> Position
                       -> BoardDecorator
                       -> Exp BoardDecorator
type instance Eval (MoveWithPreChecks fromPos toPos boardDec) = Eval (
    (MoveNoChecks fromPos toPos .
        CanMoveCheck fromPos toPos .
        NotTakingKingCheck toPos .
        NotTakingOwnTeamCheck toPos .
        NotSamePosCheck fromPos toPos .
        NotLastToMoveCheck fromPos .
        TeamCheck fromPos) boardDec)
\end{lstlisting}

However, we leave the post-move checks in the original \inline{Move} family, joining the two with a call to \inline{MoveWithPreChecks}:

\begin{lstlisting}
data Move :: Position
          -> Position
          -> BoardDecorator
          -> Exp BoardDecorator
type instance Eval (Move fromPos toPos boardDec)
    = Eval ((ShouldHavePromotedCheck toPos . CheckNoCheck)
        (Eval (MoveWithPreChecks fromPos toPos boardDec)))
\end{lstlisting}

While the cause for this increase in performance is unknown, we speculate it may be related to the number of type variables that must be unified at a given time. In any case, this example shows that sometimes improvements to algorithmic complexity of type-level programs can make little difference, while simply restructuring the type families can. Therefore, we believe that there is a need for better tooling as part of GHC to understand what causes such spikes in compile time and memory usage.

\subsection{Type Applications vs. Type Signatures}

We observed a difference in behaviour between type signatures and type applications. Initially, we did not define \inline{StartDec} by hand for use in the definition of \inline{chess} and instead pieced it together through a lengthy series of type family applications:
\begin{lstlisting}
type StartDec = MakeDecorator (ExpensiveOperation (...))
\end{lstlisting}
With this initial version of \inline{StartDec} to set up the game, we attempted two definitions of \inline{chess}: one using a type application and the other using a type signature. These definitions, given below, should be equivalent:
\begin{lstlisting}
chess :: Spec (Proxy StartDec)
chess cont = cont (Proxy @StartDec)

chess :: Spec (Proxy StartDec)
chess cont = cont (Proxy :: Proxy StartDec)
\end{lstlisting}
The version of \inline{chess} using a type application compiles without issues, but causes lengthy (sometimes unrecoverable) pauses at runtime when used. Conversely, when compiling the type signature version, GHC either fails to terminate or crashes due to a lack of memory. This difference in behaviour between the definitions is unexpected and resulted in GHC bug report\footnote{\url{https://gitlab.haskell.org/ghc/ghc/-/issues/18902}}. As a work-around, we have written out \inline{StartDec}'s definition in full in the Haskell source file, allowing compilation and usage of either definition with no issues.

\subsection{Descriptive Error Messages}

We intended for Chesskell's type errors to include the number of the move which resulted in a rule violation, to make errors as clear as possible. Ideally, this would result in error messages such as the one below:

\begin{lstlisting}
-- Below results in the following type error:
-- * There is no valid move from E2 to E5.
--   The Pawn at E2 can move to: E3, E4
--   At move: 1
-- * When checking the inferred type
--   game :: Data.Proxy.Proxy (...)
game = chess pawn e2 to e5 end
\end{lstlisting}

However, adding the move number (taken from the current \inline{BoardDecorator}) to Chesskell's error messages in this manner causes spikes in compile time and memory usage: a game consisting of a single erroneous move, such as the above, results in nearly 26GB of memory usage, and takes close to 2 minutes to compile. For reference, the average compile time and memory usage for that single move game are under 20 seconds and 4.5GB respectively.

Taking other information from the \inline{BoardDecorator} type, such as the position of one of the Kings, and putting it into the error message does not result in similar spikes. Due to its effect on compile time and memory usage, Chesskell error messages do not include the move which broke the rule. Instead, we ensure that Chesskell error messages are detailed enough that the user should be able to find the location of the error.

\subsection{Chesskell Shorthand} \label{shorthand}

One of the most dramatic optimisations in terms of compile-time and memory usage was unexpected and accidental: it resulted from the implementation of the shorthand syntax (\cref{shorthandexplanation}).

With the longhand notation, any Chesskell game longer than 10 moves would cause GHC to crash (on the authors' machines). We predicted that the shorthand syntax would degrade performance and reduce this number, since the type-level model of Chess would not only have to perform all of the move checking, but also determine which piece(s) could move to the destination square. However, since it allowed more concise description of Chess games in line with existing Chess notation, we deemed this trade-off acceptable.

We developed a working version of the shorthand syntax, without going through extensive optimisations or performance testing. Despite the greater amount of work required from GHC to compile these short-hand descriptions, there were notable and significant decreases in average compile time and memory usage: with the longhand syntax, compiling a 10-move Chesskell game took an average of 3 minutes and 25GB of memory, and a 12-move Chesskell game would crash every time. With the shorthand syntax, a 10-move Chesskell game compiles in around 1 minute 20 seconds, using 24GB of memory, and a 12-move Chesskell game compiles in an average of 1 minute 50 seconds, using 25GB of memory.

The shorthand syntax allows for us to express games which are longer by 2 moves, and yet incur no additional penalties on compile time or memory usage. We again speculate that the improvement is due to fewer type variables that need to be unified.

\section{Performance Analysis} \label{performanceanalysis}

As compile-time and memory usage proved to be a prevalent issue, we performed a more rigorous form of performance analysis towards the end of development, comparing how multiple Chess games affected Chesskell in terms of memory usage and compile time.

All of the Chess games mentioned were expressed in Chesskell's shorthand syntax (see \cref{shorthand}), with a variable number of moves: either 6, 8, or 10. For each game, we tabulate the information gathered on compile time and memory usage, both of which were averaged over three runs of each game for each move limit.

The games compared are:

\begin{itemize}
    \item The 1964/65 USSR Championship game between Ratmir Kholmov and David Bronstein (mentioned in \cref{problemsection});
    \item The 1918 "Berlin Four Masters" game between Akiba Rubinstein and Milan Vidmar;
    \item The 2019 Chinese League game between Zeyu Xiang and Yibo Zhou;
    \item The 2004 Calvia Olympiad game between Julio Ernesto Granda Zuniga and Pedro Mascaro March.
\end{itemize}

As we can see in \cref{performancetable}, the results are consistent with previous behaviour; as the number of moves increases, so too does the memory usage and compile time.

% TODO: Write more??

\begin{table}[h]
    \centering
    \label{performancetable}
    \begin{tabular}{l|ll|ll|ll}
                   & \multicolumn{2}{|l|}{6 moves} & \multicolumn{2}{|l|}{8 moves} & \multicolumn{2}{|l}{10 moves}                      \\
                   & GB                            & Mins                          & GB                            & Mins & GB   & Mins \\
        \hline
        Kholmov    & 13.1                          & 1:41                          & 15.2                          & 2:07 & 24.4 & 2:59 \\
        Rubinstein & 12.4                          & 1:27                          & 24.8                          & 3:27 & 25.9 & 6:10 \\
        Xiang      & 13.0                          & 1:31                          & 25.0                          & 3:02 & 25.8 & 4:28 \\
        Zuniga     & 12.9                          & 1:32                          & 15.2                          & 2:05 & 22.8 & 2:48
    \end{tabular}
    \caption{A table displaying the memory usage (in GB) and the compile time (in minutes) for a selection of Chesskell games.}
\end{table}

\section{Chesskell EDSL vs Other Chess Notations}

One of the aims of Chesskell was for the final Chess EDSL to be closer to existing Chess notation than to Haskell syntax. In this section, we lay out how successful Chesskell has been in this regard, with justifications where Chesskell differs from existing notation.

\subsection{Comparison with Algebraic Notation}

Since FIDE uses Algebraic Notation, it was taken as the exemplary Chess notation to aim towards. In this notation, Chess games are described move-by-move, using the destination square and the piece type for each move. A game equivalent to that given in \cref{examplegame} is given below:

\begin{verbatim}
1. e4 f5 2. Qf3 g5 3. Qh5
\end{verbatim}

There are some differences between Algebraic Notation and Chesskell syntax that are immediately apparent. First of all, Chesskell includes pawns as a piece type in their movement (e.g. \inline{p e4}), whereas Algebraic Notation only uses the destination square. Pawns are included as a piece type in Chesskell, as leaving them out would complicate the relevant continuations. While it does increase the character count when expressing the move, it simplifies implementation and improves clarity to include them, so we deem this trade-off acceptable.

Other differences (such as the space between the piece type and destination square, or the move count) are made for similar reasons, and for personal taste. Below, we outline a few of the more interesting differences.

\subsection{Captures}

Capture moves are usually treated as a special case, having their own special notation. For instance, in Algebraic Notation, capture moves include an x character to set them apart from non-capture moves. As an example, consider a Knight moving to the square d4. If the Knight does not capture another piece, then this is expressed as \wmove{Nd4}. However, if the Knight does indeed remove another piece from play, then the move should be written \wmove{Nxd4}.

Chesskell notation does not treat capture moves as a special case. A move, whether capturing or otherwise, is expressed the same way; the above move would be \wmove{n d4}. Interestingly, this makes Chesskell closer to Minimal Algebraic Notation, which also does not include (similar to Chesskell) special notation for Check, En Passant Capture, and Checkmate.

\subsection{Castling} \label{castleextension}

Notations such as Algebraic Notation tend to have specific notation for Castling; since it is a unique move which moves more than one piece, it is a useful signpost for the reader to update their mental model. Castling is expressed in algebraic notation as either \wmove{0-0} or \wmove{0-0-0}, to represent kingside and queenside castling, respectively.

In Chesskell, castling can be expressed as a King movement: such as \inline{k c1}, and requires no special notation. However, some people may prefer a clearer sign that a move is a castle, and so we include castling notation with the help of a single type family: \inline{CastleMove}. This type family takes in a \inline{BoardDecorator}, representing the current state of the board, and a boolean argument, stating whether the castle move is to the left or right. It returns the new state of the board in which the relevant castling move has been made.

For instance, when the boolean argument is \inline{True}, the relevant King is castling to the right. If the last team to move was \inline{Black}, then the currently moving team is \inline{White} -- and so the target castle position must be g1:

\begin{lstlisting}
type family CastleMove (l :: Bool) (b :: BoardDecorator) :: BoardDecorator where
    CastleMove True  (Dec board Black pos kings n) = MoveTo King (At G Nat1) (Dec board Black pos kings n)
    -- ...
\end{lstlisting}

Conversely, if the last team was \inline{White}, and the castle is to the left, then the Black King will be moving to c1:

\begin{lstlisting}
    -- ...
    CastleMove False (Dec board White pos kings n) = MoveTo King (At C Nat8) (Dec board White pos kings n)
    -- ...
\end{lstlisting}

We use this type family in the definition of new continuations, modelled after the Algebraic Notation castling descriptors:

\begin{lstlisting}
o_o :: Proxy (b :: BoardDecorator) -> Spec (Proxy (CastleMove True b))
o_o (dec :: Proxy b) cont = cont (Proxy @(CastleMove True b))
o_o_o :: Proxy (b :: BoardDecorator) -> Spec (Proxy (CastleMove False b))
o_o_o (dec :: Proxy b) cont = cont (Proxy @(CastleMove False b))
\end{lstlisting}

With the above definitions, Chesskell can include special castling notation if the user wishes to express castling in this more noticeable way; otherwise, they can default to the usual Chesskell notation format.

\subsection{Comparison with other Chess notations}

Algebraic Notation is not the only Chess notation; there are many others. We consider a few here, and how they are similar to and differ from Chesskell.

\subsubsection{Smith Notation} \label{smithsection}

Smith Notation, developed for the International Chess Club online server, is one of the more descriptive forms of Chess notation\footnote{\url{https://web.archive.org/web/20160117212352/https://www.chessclub.com/chessviewer/smith.html}}. To describe a move, both the source and the destination squares are included; as well as the piece captured, if any. Smith Notation expresses piece types similarly to Algebraic Notation -- with capital letters. Additionally, when a promotion is made, the piece type being promoted to is included. The additional detail makes this notation rather similar to (although more concise than) Chesskell's long-form syntax. Consider the move by a Queen from a2 to b3: in Chesskell, we express this as follows:

\begin{lstlisting}
queen a2 to b3
\end{lstlisting}

In Smith notation, this becomes:

\begin{verbatim}
    a2b3Q
\end{verbatim}

\subsubsection{ICCF Numeric Notation} \label{numberextension}

ICCF Numeric Notation~\cite{iccfnotation} is intended for international games of Chess, whereby Algebraic Notation can cause confusion. In Algebraic Notation (and in Chesskell), the English names for pieces are used; but in other languages, there are other names for the piece types, and so for non-English speakers the notation can be confusing. ICCF Numeric Notation remedies this by describing moves in terms of their origin and destination squares, thereby negating the need to include a piece type in the move description -- and when piece types are necessary (such as when performing promotion), to use numbers rather than names. For instance, the example move in \cref{smithsection} can be expressed as follows, using numeric representations for the positions (a2 becomes 12, and b3 becomes 23):

\begin{verbatim}
    1223
\end{verbatim}

While Chesskell was made in an English-speaking country by an English speaker, there is no reason not to include clearer notation for those from all around the world. As such, we define continuations similar to the piece continuations, but using numbers instead. Below is the same game as the one we describe in \cref{examplegame}, making use of some of these new continuations (\inline{_5} for Pawns, and \inline{_1} for Queens):

\begin{lstlisting}
game = chess
    _5 e4 _5 f5
    _1 f3 _5 g5
    _1 h5
end
\end{lstlisting}

Additionally, as opposed to using the letters a-h to describe columns, we can use a number instead, as in ICCF Numeric Notation:

\begin{lstlisting}
game = chess
    _5 _54 _5 _65
    _1 _63 _5 _75
    _1 _85
end
\end{lstlisting}