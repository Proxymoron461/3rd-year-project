\section{Self-assessment}

This section details the author's self-assessment of the project; as such, it is written in first-person singular, and addresses the relevant questions directly.

\subsection{What is the (technical) contribution of this project?}

The primary contribution is a full type-level model of Chess in Haskell, paired with value-level EDSLs which are typed with the type-level Chess model. The Haskell compiler, GHC, uses the type-level model to type-check games described with the EDSLs. Additionally, the project highlights points of friction for GHC performance --- which is useful for the implementors of GHC as it identifies some current limitations of type-level programming in Haskell. Furthermore, Chesskell itself could be used as a benchmark for GHC type-checking performance, owing to its complexity and use of many advanced features. The final major contribution is a paper submission to the Haskell Symposium 2021, discussing the contributions that Chesskell makes to the Haskell community.

\subsection{Why should this contribution be considered relevant and important for the subject of your degree?}

Chesskell is useful to Computer Science as a whole due to its focus: practical applications of strong type systems, in the context of Haskell and GHC. As I discuss above, Haskell's type system has been the subject of much academic research and years of real-world, practical use. However, the use of advanced features of Haskell's type system is often small in scope in real programs. It is therefore worthwhile to explore whether Haskell's type system is mature enough to encode more sophisticated rule sets, and what issues are impeding this from becoming common practice in industry. My work has shown that there are still significant performance hindrances which prevent this approach from becoming commonplace, and more work is required by the GHC developers to optimise the compiler for these use cases.

\subsection{How can others make use of the work in this project?}

Chesskell includes a complete type-level model of the FIDE laws of Chess. The code is open source, so anyone who wishes to write programs which use static verification involving Chess rules (such as a typed Chess engine) can make use of Chesskell to check invariants in the types of their program. Furthermore, the benchmarks we have developed can be used by Haskell compiler implementors to assess type-checking performance. Finally, the First Class Family type-level versions of common value-level Haskell type classes (such as Monads, Foldable data structures, and Functors) are reusable and can be included in Haskell projects involving type-level programming.

\subsection{Why should this project be considered an achievement?}

Implementing Chess at the type level involved learning many techniques for type-level programming, going significantly beyond content covered in modules such as CS141 Functional Programming, and familiarising myself with state-of-the-art research in the field. Once I had learned these techniques, I had to figure out how to use them to implement Chess at the type level, which has never been achieved before. To my knowledge, it is the most complex rule set expressed at the type level in Haskell to date. Furthermore, the Haskell Symposium 2021 paper concerning Chesskell is an achievement on its own --- and the feedback on the paper is fairly positive and recognises the technical achievement of Chesskell itself.

\subsection{What are the limitations of this project?}

Currently, the limit to the game size on the author's hardware (12 moves or fewer) is the biggest limitation, brought about by the excessive memory usage of GHC when type-checking Chesskell games. Addressing this problem would require improving the performance of the compiler itself, which is outside the scope of the project and would require very intimate knowledge of GHC internals. Conceptually, with more/infinitely powerful hardware, there is no limit to Chesskell game length.
