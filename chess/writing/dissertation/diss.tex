\documentclass[12pt, a4paper, bibliography=totocnumbered]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{xurl}
\usepackage{listings}
\usepackage{FiraSans}
\usepackage{palatino}
\usepackage[T1]{fontenc}  % Correct formatting for >, <, |, etc.
\usepackage{FiraMono}  % Keep last to maintain monospace font
\usepackage{xcolor}
\usepackage{parskip}
\usepackage[multiple]{footmisc}
\usepackage{skak}

\definecolor{background}{rgb}{0.97, 0.97, 0.97}
\definecolor{comments}{rgb}{0.0, 0.64, 0.0}
\definecolor{keywords}{rgb}{0.0, 0.0, 0.64}
\definecolor{identifiers}{rgb}{0.63, 0.81, 0.94}
\definecolor{strings}{rgb}{1.0, 0.3, 0.0}

\lstset{
    language=haskell,
    basicstyle=\footnotesize\ttfamily,
    backgroundcolor=\color{background},
    keywordstyle=\color{keywords}\bfseries,
    commentstyle=\color{comments}\textit,
    stringstyle=\color{strings},
    % identifierstyle=\color{identifiers},
    breakatwhitespace=true,
    breaklines=true,
    keepspaces=true,
    captionpos=b,
    frame=tlbr,    % Margin at all 4 sides
    framesep=4pt,  % Margin size
    framerule=0pt,
    morekeywords={Eval, Exp, family, instance},
    deletekeywords={map, and, error, take}
}

\setkomafont{sectioning}{\firamedium}

% Change abstract appearance
\renewenvironment{abstract}
 {\small
  \begin{center}
  \bfseries \textit{\abstractname}\vspace{-.5em}\vspace{0pt}
  \end{center}
  \quotation}
 {\endquotation}

% Custom command for all inline code styling
\newcommand{\inline}[1]{\lstinline[basicstyle=\ttfamily\footnotesize]{#1}}

\title{Chesskell: Embedding a Two-Player Game in Haskell's type system}
\author{Toby Bailey}
\date{\today}

\begin{document}

\begin{titlepage}
    \maketitle
\end{titlepage}

\phantomsection
\addcontentsline{toc}{chapter}{Abstract}
\begin{abstract}
    Type-level programming, a relatively recent phenomenon, allows programmers to express computation during the compilation of their programs. Through the use of type-level constructs, rules can be imposed on code to ensure that if it compiles, then it behaves in a certain way. However, there is still plenty of room to push the boundaries of what can be achieved with type-level programming.

    Chess has a well-defined ruleset, and has not been expressed at the type level before. This dissertation describes the development of Chesskell, a full type-level model of, and rule-checker for, Chess---along with a Haskell-Embedded Domain-Specific Language for notating Chess games. If the Chesskell code compiles, then the match described obeys the full International Chess Federation ruleset for Chess. Despite difficulties during development, including memory issues, the final version of Chesskell is feature-complete and supports Chess games of up to 10 moves.

    \textbf{\textit{Keywords:}} Type-level Programming, Haskell, Chess, EDSL.
\end{abstract}

{
\newpage  % So that \phantomsection lines up nicely
\phantomsection
\addcontentsline{toc}{chapter}{Contents}
\renewcommand{\normalfont}{\usekomafont{sectioning}}
\usekomafont{sectioning}{\tableofcontents}
}

\chapter{Introduction}

The study of programming languages in Computer Science involves, in large part, the study of type systems. Many of the interesting differences between programming languages lie not in their syntax, but in their semantics; in their behaviour. Since types govern the behaviour of languages, it is fair to say that the difference in type systems between languages forms the basis of what individuals like or dislike about programming in a specific language. Part of why assembly language can be so difficult to reason about at scale is because it is untyped; everything is a byte. C and other higher-level languages have been introduced for the programmer's benefit. With higher levels of abstraction, and more complex type systems, can come more safety, as well as clearer program behaviour.

Programming languages have \emph{type systems} for the main purpose of avoiding errors \cite{cardellitypes}. A \emph{type error} is an instance of attempting to perform a computation on something which does not support that computation. For example, it makes no logical sense to add the number 3 to a dog. This stems from the fact that "3" and "dog" support different behaviours\footnote{For instance, dogs can bark, but the number 3 cannot.}. Therefore, in a programming context, "3" and "dog" have distinct types; 3 is a number, and a dog is an animal. By assigning a type to values, programmers and the languages they use have an easier way to determine the valid operations on a value, and avoid type errors through misuse.

A notable area in which languages differ is \emph{when} they detect type errors. A \emph{static} type system is one in which type errors are detected before the program is run (during compilation), and a \emph{dynamic} type system is one in which type errors are detected while the program is running. A static type system is preferable for runtime safety, since it ensures that any running program will avoid (at least some) type errors.

Of course, as programming languages evolve, many have begun to address more and more errors at compile time (through the type system). Features similar to optional types have been added to languages such as Java\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html}} and C\#\footnote{\url{https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references}}, and languages like Rust have pioneered ways of safely handling dynamic allocation through ownership types\footnote{\url{https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html}}. Many compilers now force the developer to handle classes of errors that previously could only be encountered at runtime, such as null pointer exceptions.

However, one type of error that typically evades the type system is a \emph{logical error}---some (typically domain-specific) behaviour that is not guarded against by a language's type system. Catching logical errors in imperative languages is almost always done during execution. Many software systems use runtime features such as exceptions to discover and deal with errors and misuse of APIs. Enforcement of invariants and rules is typically dynamic; if a check fails, an exception is thrown and potentially handled. However, if a programmer forgets to implement such a check, the program behaviour becomes unpredictable. A 2007 study \cite{exceptionsusedpoorly} on Java and .NET codebases indicates that exceptions are rarely used to recover from errors, and a 2016 analysis of Java codebases \cite{badjavaexceptions} reveals that exceptions are commonly misused in Java.

Recent versions of the \emph{Glasgow Haskell Compiler} (GHC) support programming at the type level, allowing programmers to compute with types in the same way that languages like C or Python compute with values \cite{givingpromotion}, using \emph{type families} \cite{opentfs} \cite{closedtfs} that emulate functions at the type-level. These computations run at compile time, before the compiler generates an executable of the source code, allowing programmers to transform logic errors into type errors \cite{twt}. The exception misuse described above could be avoided by employing logical invariant checks at the type-level, rather than at runtime.

Since these are relatively recent developments, there are few examples of their usage in complex applications. It is worth pushing the boundaries of existing type systems, and seeing what kind of logical behaviour can be modelled (and enforced) through type-level checks. In this project, we show how to utilise type-level programming features in Haskell in order to model the classic board game Chess in Haskell's type system, ruling out invalid moves at the type-level. A Haskell-Embedded Domain-Specific Language (DSL), for describing games of Chess, will interact with the type-level model. This Embedded DSL (EDSL) will be modelled on Algebraic Notation, a method of writing down the moves associated with a particular match of Chess. We implement the full, official International Chess Federation (FIDE) ruleset for Chess.

A growing number of new languages have type systems which support \emph{Dependent types}, in which the types themselves depend on runtime values, and can be treated as values. The programming language Idris is similar to Haskell, but allows the programmer to pass around types at runtime, and write functions which operate on those types. Many of Haskell's language extensions have been adding to its type system, moving the language closer and closer towards dependently typed programming \cite{singletons}. Such a type system has obvious benefits, since constraining the types means constraining the values without dynamic runtime checks. (For example, in a dependently typed environment, runtime array bounds checks can be eliminated at runtime through being expressed solely in the type system \cite{dependentarray}.)

Chess is suitable to model at the type-level due to its well-defined ruleset. Programming language type systems will evolve through usage, and so programs will and should be written to test what's possible to express at the type level. Chess is a widely understood, popular, and rigorously documented game, making it a natural fit to help push the boundaries of type-level programming. Simulating, and checking for rule violations within, a Chess game has a much wider scope than using type-level programming to avoid some dynamic checks. This project uses Chess as a case study for complex rule systems, to determine if such a thing can be modelled at the type level.

\section{Related Work}

Chesskell is, at the time of writing, unique; we are aware of no other type-level Chess implementations. There have been allusions to Chess at the type-level through solving the N-queens problem in dependently typed languages, such as Idris\footnote{\url{https://github.com/ExNexu/nqueens-idris}}. The N-queens problem makes use of some Chess rules, including the Queen's attack positions\footnote{A Queen can attack in a straight line in any direction.}; but as the end goal is not to successfully model a game of Chess, it is not a full type-level Chess implementation.

However, Chesskell draws from, and owes much to, many well-established research areas, including type-level rule checking, EDSLs, and Chess programming in general. This section of the report will detail related work, and how Chesskell differs from existing literature.

\subsection{Type-level Rule Checking}

The idea of using types to enforce rules on behaviour is hardly specific to Haskell; C and C-like languages ensure that you only apply the correct operations on types, after all. The programming language Rust\footnote{\url{https://www.rust-lang.org/}} has been voted the most loved language (by StackOverflow developers) 5 years running\footnote{\url{https://insights.stackoverflow.com/survey/2020\#technology-most-loved-dreaded-and-wanted-languages}}. Rust is touted as a systems language that guarantees memory safety and thread safety; and it achieves this through its type system. By enforcing strict ownership rules, Rust can guarantee that your programs avoid data races and that all memory is freed once and not used after being freed. This is a clear example of types enforcing runtime behaviour; but instead of Chess rules, a series of memory rules are being enforced. In fact, Haskell type-level constructs can be used to enforce basic ownership rules through a method colloquially known as the "ST Trick" \cite{twt}.

Of course, type-level rule checking in Haskell is very possible. Through clever use of types, Lindley and McBride's merge sort implementation \cite{hasochism} is guaranteed to produce sorted outputs. Unit tests for the sorting implementation become unnecessary, since the GHC type checker is used to ensure that the sort itself behaves correctly. The type system is used to enforce the rule that sorted data should be in sort order.

The above examples may seem unrelated to the ruleset of Chess, but they demonstrate the fact that type-level behaviour enforcement is neither new nor specific to Haskell. Though type systems can be complex, since many languages are designed to be general-purpose their type systems are also designed to be so. Chesskell represents an attempt at capturing domain-specific knowledge at the type level, and using that knowledge to maintain safe behaviour. Chesskell, and other type-level behaviour enforcers, are not common simply because logic errors are usually dealt with through dynamic checks (it is certainly easier to write dynamic unit tests than it is to model your application domain with types).

\subsection{Haskell-Embedded Domain-Specific Languages}

Despite the apparent lack of work on Chess at the type level specifically, there is work on Haskell-Embedded DSLs in other domains to enforce certain behaviour at compile time. DSLs exist for the purpose of modelling some domain in a language; so Haskell-Embedded DSLs are a natural use case for domain-specific modelling with types. If an EDSL comes with the guarantee that all compiling programs written in that language will not exhibit invalid behaviour, then the EDSL becomes an attractive way to interact with that domain.

Mezzo \cite{mezzohaskellsymposium} is an EDSL for music composition, which checks if the described piece of music conforms to a given musical ruleset during compilation of the program. For instance, one can apply classical harmony rules to ensure that the piece of music you compose would not go against the rules of the musical period. This EDSL is similar to Chesskell in aim, if not in application domain; performing compile-time checks of rulesets that are commonly checked dynamically. Mezzo is an example of a complex domain with complex rules (classical harmony) being modelled and enforced at the type-level. This is similar to Chesskell's objectives, and was a direct inspiration for the project.

As another example, BioShake \cite{bioshake} is an EDSL for creating performant bioinformatics computational workflows. The correctness of these workflows is checked during compilation, preventing any from being created if their execution would result in certain errors. For bioinformatics workflows especially, this is ideal since many of these workflows are lengthy. BioShake goes further, however; providing tools to allow parallel execution of these workflows. While it is encouraging to see BioShake and other EDSLs \cite{aplite} focus on (and achieve) high performance, Chesskell has no such focus. This is primarily because very few parts of the rule-checking process can be parallelised; much of the move handling and order of rule checks must be done sequentially.

\subsection{Chess in Computer Science}

Chess has a rich history as a study area of Computer Science. Getting computers to play Chess was tackled as far back as 1949 \cite{1949chess}, and since then many developments have been made in the field. Chess has been used to educate \cite{chesseducation}, to entertain, and to test out machine learning approaches \cite{chessml}. Due to its status as a widely known game of logic, with a well-defined rule set, it is a prime candidate to act as the general setting for programming problems. Indeed, the famous NP-Complete problem referenced above, the N-Queens Problem \cite{nqueensnp}, relies on the rules of Chess.

Many of these Chess-related programs are written in Haskell, and are publicly available\footnote{\url{https://github.com/mlang/chessIO}}\footnote{\url{https://github.com/nionita/Barbarossa}}. A large number are Chess engines, which take in a board state and output the move(s) which are strongest, and so therefore perform move checking at the value-level to ensure that the moves that it outputs are valid. Chesskell differs from these in function, in that the end software does not output a list of strong moves; it simply takes in the moves performed, and state whether they are valid Chess moves or not. We are not aware of any such type-level Chess implementations in Haskell, or any other language.

Game development, as a more general field in Computer Science, has many Chess-based or Chess-related games available. However, the intention in these cases is usually to facilitate real-time play between multiple players (or indeed a single player with a competitive AI), rather than to teach or program a machine to consistently beat players. There is overlap with Chesskell; Chess as a computer game must necessarily perform move validation (to disallow cheating) and ensure that players take turns. However, Chesskell is intended to check over a complete game, rather than to enable people to conduct a game in real-time with Chesskell as a mediator.

\subsection{Why Haskell?}

Given the previous discussion on dependent type systems, and how Haskell is inching towards one, it begs the question; why not use a dependently typed language, like Idris, to write Chesskell in? The simple answer is because it would be trivial. Writing type-level code in Idris (or any other dependently typed language) would be near indistinguishable from writing a Chess validity checker, bundled within an EDSL, at the value-level. Such a feat is both simple and unoriginal.

However, choosing to write Chesskell in Haskell means figuring out how to perform typical value-level computation at the type-level. Indeed, the majority of the code for Chesskell is reusable, since much of it is not specifically about expressing the rules of Chess, but building components to enable complex computation with types. The project is both more difficult, and more interesting, for having been completed in a language without a full dependent type system.

\section{Objectives}

The objective of this project is to develop a model of Chess at the type level, which will compile a given program if and only if it is a valid game of Chess. The primary method of interfacing with this type level model will be via a custom EDSL, through which Chess games are expressed. During compilation, the game of Chess will be simulated, such that any invalid move (or the lack of a move where one should have occurred) will result in a type error. The main goals are thus:

\begin{itemize}
    \item Develop a type-level model of a Chess board;
    \item Develop a type-level move-wise model of a Chess game;
    \item Develop an EDSL to express these type-level Chess games in;
    \item Ensure (through testing) that valid Chess games compile, and invalid Chess games do not.
\end{itemize}

During the course of the project, a "valid Chess game" is any game that adheres to the FIDE 2018 Laws of Chess\footnote{\url{https://handbook.fide.com/chapter/E012018}}. The FIDE laws also contain rules for the players themselves to adhere to; but these are outside the scope of the project, since they are not directly concerning the game of Chess itself.


\chapter{Background}

Haskell is a purely functional language, which is statically typed and lazily evaluated\footnote{\url{https://www.haskell.org/}}. As we explain above, languages with a dependent type system have no separation between types and values. In Haskell however (among other languages), programs undergo \emph{type erasure}---the executable output of the compiler has no notion of types. In other words, Haskell has a clear separation between dynamic values, and the static types those values have. Haskell cannot be used to write functions on types, in the same way that a dependently typed language like Idris can.

This is just one of the differences between Haskell's type system and a dependent type system, but it is an important one; type-level programming in Haskell is made more complex due to type erasure. This chapter summarises key aspects of Haskell's type system, including how programmers can use GHC extensions and advanced features to circumvent type erasure and perform computation at the type level in Haskell.

\section{Types in Haskell}

For a Haskell compiler, such as GHC, to accept a program, it must be well-typed (that is, every expression has a valid type). In some cases, the type of an expression can be inferred, or it can be manually annotated by the programmer (in which case the compiler must unify the annotated type with the inferred type). If the expression has no permissible type, or its' inferred type does not match its programmer-annotated type, then the compiler is responsible for generating a type error.

For instance, as in many other languages, one of the possible types for \inline{3} is \inline{Int}. It would be incorrect to declare an expression of a different type, and to give it a value of \inline{3}, as below:

\begin{lstlisting}
x :: Bool
x = 3  -- error: Couldn't match expected type 'Bool' with actual type 'Int'
\end{lstlisting}

However, Haskell has support for \emph{polymorphism}; firstly, parametric polymorphism, where a value's type is dependent on one or more \emph{type variables}. Consider the list type; it would be nonsensical to define an entire new list data type for each potential inhabitant. As such, the list type in Haskell is more general, in that it can hold any value of any type, provided that all elements of the list are of the same type. For instance, a list of booleans, such as \inline{[True, False]}, has type \inline{[Bool]}, which is notated as \inline{[True, False] :: [Bool]}.

In Haskell, type variables are conventionally named as lowercase single letters in alphabetical order; so the first general type in an type annotation is typically \inline{a}, followed by \inline{b}, \inline{c}, and so on. In fact, all Haskell types start with a capital letter, so any lowercase string is a valid type variable name (except for keywords). As such, the polymorphic empty list \inline{[]} has type \inline{[a]}, where the type variable \inline{a} can be unified with other types, such as \inline{Bool} in the example above.

Secondly, Haskell supports ad-hoc polymorphism, whereby functions can be specialised to operate on specific types, with separate definitions for each type. Haskell achieves this through \emph{type classes}, a feature which is akin to interfaces in object oriented languages. We give an example below, involving the basic equality operator in Haskell (which is a member of the \inline{Eq} typeclass). Example definitions for both \inline{Bool} and \inline{Int} are given to demonstrate how different definitions can be used for the same function:

\begin{lstlisting}
class Eq a where
    (==) :: a -> a -> Bool

instance Eq Bool where
    True  == True  = True
    False == False = True
    True  == False = False
    False == True  = False

instance Eq Int where
    0 == 0 = True
    0 == y = False
    x == 0 = False
    x == y = if x > 0 then (x - 1 == y - 1) else (x + 1 == y + 1)
\end{lstlisting}

Haskell functions are of the form \inline{a -> b}, for some type variables \inline{a} and \inline{b} which can unify with any other type, including function types. For instance, Boolean logical AND would have the type \inline{Bool -> Bool -> Bool}, while logical NOT would have the type \inline{Bool -> Bool}.

All Haskell functions can be curried \cite{currying}; as an example, assume the definition of a function \inline{and}, which performs logical AND on its two inputs. The type of \inline{and} would be \inline{Bool -> Bool -> Bool}, while the type of \inline{and True} would be \inline{Bool -> Bool}, and the type of \inline{and True False} would just be \inline{Bool}. The expression \inline{and True} is well-typed, and would compile; contrasting with other languages such as C or Java, in which functions cannot be partially applied and an analogous expression (e.g. \inline{and(True)}) would fail with a type error.

Haskell allows the programmer to define their own data type with the keyword \inline{data}. These data types are \emph{algebraic}, meaning that they are types comprised of other types. For instance, to define a "Hand" type, where someone can hold something on each finger, the definition would be something like as follows:

\begin{lstlisting}
data Hand a = One a
            | Two a a
            | Three a a a
            | Four a a a a
            | Five a a a a a
\end{lstlisting}

However, this definition syntax has limitations; all of the return values of the type constructors above must be \inline{Hand a}. A GHC extension allows the definition of \emph{Generalised Algebraic Data Types} (GADTs) \cite{gadts} which allows more complex type constructor definitions. The above \inline{Hand} datatype could be expressed thus:

\begin{lstlisting}
data Hand a where
    One   :: a -> Hand a
    Two   :: a -> a -> Hand a
    Three :: a -> a -> a -> Hand a
    Four  :: a -> a -> a -> a -> Hand a
    Five  :: a -> a -> a -> a -> a -> Hand a
\end{lstlisting}

Furthermore, if you wished to modify \inline{Hand} to ensure that it always stored \inline{Int} values on odd fingers, and \inline{Bool} values on even fingers, you can achieve that with GADTs like so:

\begin{lstlisting}
data Hand a where
    One   :: Int  -> Hand Int
    Two   :: Bool -> Int  -> Hand Bool
    Three :: Int  -> Bool -> Int  -> Hand Int
    Four  :: Bool -> Int  -> Bool -> Int  -> Hand Bool
    Five  :: Int  -> Bool -> Int  -> Bool -> Int  -> Hand Int
\end{lstlisting}

% \section{Lazy Evaluation}

% Haskell is a \emph{lazily evaluated} language, which means that values are computed on-demand. This contrasts with \emph{eagerly evaluated languages} like C or Java, which evaluate their arguments before applying functions. A good example of this behaviour is with infinite list types. Trivially, if a program tries to fully evaluate an infinite list, then it will never terminate. However, in a lazily evaluated environment, an infinite list can be used for computation.

% Consider the following example, where the \inline{(:)} operator adds an element to the beginning of a list, and \inline{take n list} takes \inline{n} elements from the start of \inline{list}. One could define an infinite list as such:

% \begin{lstlisting}
% infiniteList = 1 : infiniteList
% \end{lstlisting}

% With such a definition, the expression \inline{take 5 infiniteList} both terminates and is well-typed, returning the value \inline{[1,1,1,1,1]}.

% Another example demonstrates lazy evaluation: in Haskell, the \inline{undefined} value simply throws an exception whenever evaluated. We use it to demonstrate Haskell lazy evaluation: consider an expression \inline{list} defined as \inline{list = [1,2,3,undefined]} (which compiles successfully). \inline{take 3 list} evaluates to \inline{[1,2,3]}, while \inline{take 4 list} generates an exception. For a non-list example, consider if expressions. \inline{if True then 3 else undefined} evaluates to \inline{3}, since the else branch is not evaluated.

% All values in Haskell are lazily evaluated (unless explicitly set otherwise in code). The expression \inline{5 + 2 * 3} will only be evaluated to \inline{11} when that value is required somewhere in code, and if it is never required, it is never evaluated.

\section{Type-level Programming}

While GADTs and lazy evaluation are certainly useful in day-to-day programming, they are not enough to achieve complex type-level computation. Luckily, there are many more GHC extensions, a large number of which bring the language closer to dependent types.

\subsection{Kind Promotion}

A key concept in type-level programming in Haskell is that of \emph{promotion} \cite{givingpromotion}. The data types that programmers define (as we explain above) can be promoted to \emph{kinds}. Kinds are, conceptually, the types of types; that is, values have types, and types have kinds. A type of kind \inline{*} takes no type variables, and a type of kind \inline{* -> * -> *} takes in two type variables and returns a type. Consider an empty list, which takes a type variable; it has kind \inline{* -> *}, while the kind of a Boolean list (\inline{[Bool]}) is \inline{*}.

The kind \inline{*} is commonly aliased as \inline{Type}, since it is the kind of types which have runtime values. That distinction becomes important when promotion is involved; programmers can define their own kinds with the \inline{-XDataKinds} extension enabled. Consider a custom \inline{Book} data type, which is either \inline{Fiction} or \inline{NonFiction}. A type definition may look as follows, with either regular or GADT syntax:

\begin{lstlisting}
data Book = Fiction | NonFiction

data Book where
    Fiction :: Book
    NonFiction :: Book
\end{lstlisting}

With the \inline{-XDataKinds} extension enabled, the above code not only produces the two values \inline{Fiction} and \inline{NonFiction} with type \inline{Book}, but also the \emph{types} \inline{'Fiction} and \inline{'NonFiction}, of kind \inline{Book}. The key point of understanding is that there are no values of type \inline{'Fiction} or \inline{'NonFiction}---they exist solely at the type level.

The syntax for "has type" and "has kind" is in both cases \inline{::}, which is unfortunate; however, in the rest of the document, where the distinction is unclear, it shall be made so. Additionally, the prefix \inline{'} for promoted types is optional, and can be left out where the compiler can unambiguously state whether an expression should be a type or a value.

\subsection{Type Families}

Another key extension introduces \emph{type families} \cite{opentfs} \cite{closedtfs}. Type families allow the programmer to compute over types just as functions compute over values; they are the type-level analogue to functions, and come with their own syntax. Following on from the \inline{Book} example above, consider a type family \inline{IsFiction}, which states whether a given \inline{Book} is fiction or not. A value-level definition could be as follows:

\begin{lstlisting}
isFiction :: Book -> Bool
isFiction Fiction    = True
isFiction NonFiction = False
\end{lstlisting}

And the type family analogue is thus, where \inline{::} below means "has kind":

\begin{lstlisting}
type family IsFiction (x :: Book) :: Bool where
    IsFiction 'Fiction    = True
    IsFiction 'NonFiction = False
\end{lstlisting}

Both function and family use pattern-matching, and although the type family syntax is a little more verbose, it is still clear. However, the above is a \emph{closed} type family; programmers can define \emph{open} type families which can be extended beyond their initial definition. This mimics ad-hoc polymorphism, in that different implementations of the same type family can be offered with different types as input.

There are more notable differences between (closed) type families and functions beyond syntax. The most important is that type families cannot be partially applied in the same way that functions can. Consider a function (and closed type family) \inline{IsEitherFiction}, which takes in two books and states whether either of them are fiction or not. A function definition, and a closed type family definition, are below:

\begin{lstlisting}
isEitherFiction :: Book -> Book -> Book
isEitherFiction Fiction _ = True
isEitherFiction NonFiction Fiction = True
isEitherFiction NonFiction NonFiction = False

type family IsEitherFiction (x :: Book) (y :: Book) :: Bool where
    IsEitherFiction 'Fiction _ = True
    IsEitherFiction 'NonFiction 'Fiction = True
    IsEitherFiction 'NonFiction 'NonFiction = False
\end{lstlisting}

While the function \inline{isEitherFiction} can be partially applied, the type family \inline{IsEitherFiction} cannot. One could feasibly map \inline{isEitherFiction} over a list of books, but mapping with the type family \inline{IsEitherFiction} is impossible. Imagine a type family \inline{Map}, of kind \inline{(a -> b) -> [a] -> [b]}, analogous to the value-level function \inline{map}. While the value-level expression \inline{map (isEitherFiction NonFiction) [NonFiction, Fiction]} evaluates to \inline{[False, True]}, the type-level equivalent (\inline{Map (IsEitherFiction 'NonFiction) '[ 'NonFiction, 'Fiction ]}) causes a type error.

Sadly, much of functional programming relies on partial application, and these facilities simply aren't available when using Haskell's Type Families.

% Additionally, Type Families are not lazily evaluated, but are eagerly evaluated; we demonstrate with the definition of a custom \inline{If} type family, combined with a type error:

% \begin{lstlisting}
% type family If (x :: Bool) (t :: k) (e :: k) :: k where
%     If True  x _ = x
%     If False _ y = y
% \end{lstlisting}

% The type-level expression \inline{If True 3 4} has kind \inline{Nat}, and evaluates to \inline{3}. However, the type-level expression \inline{If True 3 (TypeError (Text "Not lazily evaluating!"))} results in a type error; demonstrating that Type Family arguments are evaluated before application. Compared with the behaviour of Haskell's value-level \inline{if}, it is clear that type families are eagerly evaluated rather than lazily evaluated.

\subsection{First-Class Families}

The above problem is still an open one in type-level programming, but one solution comes from Li-yao Xia, who put together a Haskell library named First Class Families\footnote{\url{https://github.com/Lysxia/first-class-families}}. First Class Families allow the programmer to map over structures, and specialise type families (a la ad-hoc polymorphism), similar to value-level functions. Sadly, First Class Families is not supported by any formal literature on the topic at the time of writing; so we briefly introduce and explain the concept below.

It relies on a type, \inline{Exp}, and an open type family, \inline{Eval}. They are defined like so:

\begin{lstlisting}
type Exp a = a -> *
type family Eval (e :: Exp a) :: a
\end{lstlisting}

Using these two definitions, a type-level interpreter becomes available for use. While type families cannot be partially applied, type and kind constructors have no such restriction; and so passing around the types as \inline{Exp} types allow the programmer to partially apply, and to evaluate whenever they choose by calling \inline{Eval}. For instance, consider the \inline{IsEitherFiction} type family, but defined in "First Class Family" style instead:

\begin{lstlisting}
data IsEitherFiction :: Book -> Book -> Exp Bool
type instance Eval (IsEitherFiction Fiction Fiction) = True
type instance Eval (IsEitherFiction Fiction NonFiction) = True
type instance Eval (IsEitherFiction NonFiction Fiction) = True
type instance Eval (IsEitherFiction NonFiction NonFiction) = False
\end{lstlisting}

When combined with a definition of \inline{Map}, mapping (and general Functor behaviour) at the type level becomes possible by calling \inline{Eval}: the expression \inline{Eval (Map (IsEitherFiction 'NonFiction) '[ 'NonFiction, 'Fiction ])} evaluates to \inline{'[ 'False, 'True ]}.

However, since an open type family is used to define First Class Families, they cannot have overlapping definitions. For instance, the below will not compile:

\begin{lstlisting}
data IsEitherFiction :: Book -> Book -> Exp Bool
type instance Eval (IsEitherFiction Fiction _) = True
type instance Eval (IsEitherFiction x Fiction) = True
type instance Eval (IsEitherFiction x NonFiction) = False
\end{lstlisting}

When using a closed type family, or a value-level function, the definitions written are implicitly ordered, so if instances overlap, the behaviour is to default to the first definition written. Luckily, this can be leveraged; by using a combination of First Class Families and closed type families, both partial application and ordered definitions can be used:

\begin{lstlisting}
data IsEitherFiction :: Book -> Book -> Exp Bool
type instance Eval (IsEitherFiction x y) = IsEitherFiction' x y

type family IsEitherFiction' (x :: Book) (y :: Book) :: Bool where
    IsEitherFiction' 'Fiction _ = True
    IsEitherFiction' x 'Fiction = True
    IsEitherFiction' x 'NonFiction = False
\end{lstlisting}

% \subsubsection{Type-level Lazy Evaluation}

% First Class Families introduce more than just partial application; they can be used to perform type-level lazy evaluation. Consider a First Class Family, \inline{TE}, which takes in an \inline{ErrorMessage} and returns a \inline{TypeError}:

% \begin{lstlisting}
% data TE :: ErrorMessage -> Exp a
% type instance Eval (TE msg) = TypeError msg
% \end{lstlisting}

% When combined with \inline{Eval}, \inline{TE} can be used to return a type error: \inline{Eval (TE (Text "Custom error!"))} generates \inline{error: Custom error!}.

% By guarding the actual type error behind \inline{Eval} calls, type errors can be lazily evaluated, as can other type level constructs. Consider another First Class Family for if statements:

% \begin{lstlisting}
% data If :: Bool -> Exp a -> Exp a -> Exp a
% type instance Eval (If True  x y) = Eval x
% type instance Eval (If False x y) = Eval y
% \end{lstlisting}

% Alongside a First Class Family version of the identity function:

% \begin{lstlisting}
% data ID :: a -> Exp a
% type instance Eval (ID x) = x
% \end{lstlisting}

% The First Class Family version of \inline{If} supports lazy evaluation; as can be demonstrated by placing an unevaluated type error in the else branch. The type-level expression \inline{Eval (If True (ID 3) (TE (Text "Not lazily evaluated!")))} evaluates to \inline{3}, rather than generating a type error.

% The behaviour of the First Class Family definition is different from that of the Closed Type Family definition we give above; the type error is never evaluated, as the \inline{Eval} call on the else branch is never made. As such, First Class Families can be used to perform lazy evaluation at the type level.

\subsection{Type Applications}

The \inline{-XTypeApplications} Haskell syntax provides a way for the programmer to directly specify type variables \cite{typeapplication}. Consider an empty list, with type \inline{[a]}. Using type application syntax, where we prefix a type name with \inline{@}, one can specify the type of an empty list by stating what type should inhabit type variable \inline{a}.

For example: the empty list \inline{[] @Int} has type \inline{[Int]}, and the empty list \inline{[] @Bool} has type \inline{[Bool]}. Note that the empty list value has been used in all cases; the thing that has changed is the type of that empty list.

\subsection{Proxies and Singletons}

While promotion and type families allow the programmer to compute at the type level, there must be some way to pass information between the value level and the type level for this to be useful. For Chesskell, this communication only needs to be one-way; the value-level EDSL passes information up to the type system, which either compiles successfully or throws a type error. Promoted types (such as \inline{'Fiction}) have no runtime values, and so cannot be used as value-level function argument types. There are two widely used methods of circumventing this limitation in Haskell to mimic values with these promoted types; \emph{proxies} and \emph{singletons}.

\subsubsection{Proxy Types}

Proxy types provide a wrapper to allow arbitrary types to have kind \inline{*}. As we explain above, all value-level functions take in values, and all values have types with kind \inline{*}. The \inline{Proxy} type constructor takes in a single type variable, and exposes a polymorphic value \inline{Proxy}. The \inline{Proxy} type constructor, when applied to some type, has kind \inline{*}. To follow on from the previous \inline{Book} example, while \inline{'NonFiction} has kind \inline{Book}, \inline{Proxy 'NonFiction} has kind \inline{*}, and so values of type \inline{Proxy 'NonFiction} can be passed around at the type level.

By making use of the type application syntax we explain above, we can demonstrate how \inline{Proxy} values can be used to pass around type variables with arbitrary kinds. While \inline{'NonFiction} has kind \inline{Book}, \inline{Proxy 'NonFiction} has kind \inline{*}. Additionally, since it has kind \inline{*}, it has a runtime value; \inline{Proxy @NonFiction} is the value of type \inline{Proxy 'NonFiction}.

\subsubsection{Singletons}

As helpful as proxy types can be, they have one limitation; since all the value-level code sees are \inline{Proxy} values, all of the relevant information is only available at the type-level. However, singleton types \cite{singletons} provide an alternative approach. Each singleton type has a single inhabitant value, and each individual value has a single unambiguous type. In other words, it's a large step towards dependently typed programming.

This is achieved through, for each defined type, running it through Richard Eisenberg's singletons library's Template Haskell definitions\footnote{\url{https://hackage.haskell.org/package/singletons}}. Template Haskell is a compile-time meta-programming system, similar to macros in that it allows programmers to define programs to modify and generate Haskell source code \cite{templatehaskell}. The singletons library uses Template Haskell to define new data types, given data type definitions. Should singletons be given the definition of the \inline{Book} datatype which we detail above, it will generate a new \inline{SBook} datatype, defined as below:

\begin{lstlisting}
data SBook :: Book -> * where
    SFiction    :: SBook 'Fiction
    SNonFiction :: SBook 'NonFiction
\end{lstlisting}

Due to datatype promotion, this introduces new values, types, and kinds. The runtime value \inline{SFiction} has the type \inline{SBook 'Fiction}, and the type \inline{'SFiction} has kind \inline{SBook Fiction}. These definitions are designed to enable the programmer to access type information through values, and vice versa.

The type of \inline{SNonFiction} can only be \inline{SBook 'NonFiction}, and so value-level code now has some intuition of types; and conversely, when given a type \inline{SBook a}, type families can use the type variable \inline{a} which will be either \inline{'Fiction} or \inline{'NonFiction}.


\chapter{Design}

This chapter of the dissertation details the general design of Chesskell. Broadly, Chesskell is split into two main sections; the type-level chess model and ruleset, and the value-level EDSL which acts as an interface for the type-level chess model.

Additionally, we explain some basic Chess knowledge in this chapter, to aid in understanding. However, we tackle the more complex rules when they become relevant; this chapter does not constitute a formal introduction to Chess, but a simple summary to make the design of Chesskell clear.

\section{The Basics of Chess}

Chess is a two-player game, played in alternating moves by players typically named \emph{Black} and \emph{White}, after the colours of their pieces. In each turn, the player will move a single piece, and cannot abstain from making a move (or move a piece from its position to that same position). Each piece is governed by its own movement rules, which depend on the state of the board and, in some cases, the history of that piece or other pieces' movements.

\subsection{The Board}

The board is an 8x8 grid of 64 square tiles, each of which is coloured Black or White such that each square is next to tiles of the opposite colour (see Figure \ref{chessboard}). The pieces move within this board, and cannot take moves that would wrap around it or take them off of the board.

At the beginning of the game, all Chess pieces lie in a specific arrangement (see Figure \ref{startboard}). All Black and all White pieces are opposite one another, such that their positions are mirrored.

\subsection{The Pieces}

While each team has 16 pieces total, there are only 6 types of pieces; Pawns, Rooks, Knights, Bishops, Queens, and Kings (in rough order of value during play). Each have their own strict movement rules, and in all but a single case, pieces of the opposite team can be \emph{captured} by moving to their square. A capture removes a piece from play; there is no way to regain a piece once captured (although there is a way to transform a Pawn into another piece). We give an example of capturing in Figure \ref{capture}.

\subsection{The Game}

A King is in \emph{check} when they are in the attack path of another piece. The objective of the game is to place the opponent's King into \emph{checkmate}, whereby every move the King could make is to a position where they would be in check (see Figure \ref{checkmate} for an example). Additionally, a move by a team that would place that team's King into check is an invalid move, and cannot be made.

There are additional ways in which a Chess game may end, such as when two opponents agree to a draw; however, these additional rules concern the players of Chess rather than the game itself, and so are not a part of the implementation of Chesskell.

\subsection{Chess Notation}

There are two main categories of chess notation; those concerning the state of the game, and those concerning the state of the board. Further relevant details on specific Chess notation will be tackled as and when relevant; this section is only aimed as a minor note of their existence.

Chess notation concerning the state of the game tends to be an account of the whole set of moves, starting from the standard start positions. Algebraic notation is the most common chess notation, and is used by FIDE to record matches between professional chess players. Each piece type other than Pawn is denoted with a capital letter: K for King, Q for Queen, B for Bishop, R for Rook, and N for Knight. As such, the move \texttt{Na4} means that a Knight has moved to the position "a4" on the board. Algebraic notation typically does not include the square the piece moved from; only its destination square. Figure \ref{algebraicexample} shows the initial state of the board, followed by a set of moves in algebraic notation, and the resulting state of the board.

There are stylised variants of Algebraic Notation, such as Figurine Algebraic Notation, in which symbols for the pieces replace the capital letter. For example, \texttt{Na4} is written as \wmove{Na4}, whereby the N is replaced with the symbol for a Knight. This is the variant used in the dissertation; future examples use Figurine Algebraic Notation, where chess symbols replace capital letters.

The other class of chess notation is that for board creation or description. Forsyth-Edwards Notation (FEN), a popular example, simply states which pieces are where on a board, line-by-line. White pieces are denoted with uppercase letters, and Black pieces are denoted with lowercase letters. The letters used match those for Algebraic Notation, save for the introduction of P for White Pawns (and p for Black Pawns). Lines are described as series of pieces and empty spaces, such that a row with a White Pawn on every other position would be described as \texttt{P1P1P1P1}. Another row with two spaces between Black Pawns would be described as \texttt{p2p2p1}, since the total number of row positions must equal eight. See Figure \ref{fenexample} for an example of a board created with FEN notation.

\section{Type-Level Data Structures}

As helpful as type families and First Class Families are in enabling computation at the type level, this computation is useless without something to compute on. Chesskell requires some central repository of information for the state of the board, as well as general data structures for passing around information while validating the Chess ruleset. This section describes the type-level data structures in Chesskell.

\subsection{Chess Data Structures}

An important part of any good Chess program is its board representation, since all other parts of the program come from this; move generation, move evaluation, and the entire search space are all defined or influenced by the board representation. A great deal of work has gone into defining memory- or time-efficient Chess boards \cite{bitboard} \cite{searchtables}, including combinations of multiple representations to yield greater speed \cite{bitandccr}. While there is value to be gleaned from examining these representations, Chesskell serves a different purpose; it does not need to search through the valid set of moves to determine which are the best, and speed is not its focus. Chesskell's board representation must be relatively efficient, but it would be naive to expect similar levels of performance from type-level constraint solving computation as from optimised value-level code.

\subsection{Singly-linked Lists}

In Chesskell, Haskell's built-in type-level lists are not used as the primary board type. These lists are singly linked, and so have a variable length which is checkable in $O(n)$ time. Ensuring that the chess board remains an 8x8 grid at all times would incur a repeated cost on the compile time of the program. However, these lists are used for data which can be of variable length; such as the list of available moves for a piece in a specific position.

\subsection{Finger Trees}

An alternative to type-level lists would be to use 2-3 Finger Trees \cite{fingertrees}. Unfortunately, singly-linked lists have no quick "append" operation. As such, combining lists of moves takes $O(n)$ time, which could be considerable for pieces like Queens who have many moves available to them at any one time. However, Finger Trees can be combined in $O(log(min(n_{1}, n_{2})))$ time, where $n_{1}$ and $n_{2}$ are the sizes of the respective FingerTrees. Singly linked lists have an $O(1)$ append, while Finger Trees have an \emph{amortized} $O(1)$ append operation.

Finger Trees are so named because while the main portion of the data is in recursive tree form, each tree maintains two "hands" full of data. Essentially, each of these appendages is a small overflow buffer for the tree itself, since inserting into the tree is more costly ($O(log n))$) than inserting into the buffer ($O(1)$). A pleasant side effect of this approach is that not only can you access data at the beginning of the sequence in $O(1)$ time, you can also access data at the end of the sequence in $O(1)$ time; something impossible with Haskell's built in singly linked lists.

Disappointingly, there exists an implementation of Chesskell using Finger Trees as opposed to lists for variable length data, but as we discuss in the Evaluation chapter, there was no significant increase in compile time relative to the effort spent implementing Finger Trees at the type level.

\subsection{Length-indexed Vectors}

If the intention is to use it for representing a Chess board (or any other structure with a definite length), singly-linked lists have issues; how can we ensure that the chess board is the appropriate size (an 8x8 grid) without a length check each move? This would take at least 56 additions, since list length is computed recursively; as well as 7 more addition operations to put together the list lengths.

A more desirable data structure would be one that had a fixed type, which could be guaranteed to remain at length 8. As such, Chesskell makes use of a variant of singly-linked lists, named length-indexed vectors. A length-indexed vector is a singly linked list which contains its' length in its' type. That is, a length-indexed vector of size 0 has a different type than a length-indexed vector of size 3. As with most things in Haskell, we use recursive definitions; an empty vector has length 0, and you express a vector of length (n + 1) by pushing an element to the front of a vector of length n. We give an example GADT data type definition below:

\begin{lstlisting}
data Vec (n :: Nat) (a :: *) where
    VEnd   :: Vec 0 a
    (:->)  :: a -> Vec n a -> Vec (n + 1) a
\end{lstlisting}

If the programmer should require the input vector to be of length 5, then all they must do is include its length in the function definition:

\begin{lstlisting}
someFunc :: Vec 5 a -> b
someFunc vec = -- ...
\end{lstlisting}

This makes it a perfect candidate to act as the central chess board type, containing all pieces. To guarantee that a board is an 8x8 grid, it simply needs to contain 8 length-indexed vectors of length 8. Due to the use of the \inline{-XDataKinds} extension to enable promotion, this length-indexed vector definition immediately also defines a type-level length-indexed vector.

Almost all operations available on lists are available on length indexed vectors. However, since length-indexed vectors have an additional type variable (their length), they are difficult to dynamically create without some length type variable. That is, a function \inline{f :: a -> Vec n b} cannot exist, since the type variable \inline{n} will have nothing to unify with when \inline{f} is called.

\subsection{Type-Level Bitboards}

One popular Chess board representation is the Bitboard \cite{bitboard}; using a set of 64-bit binary strings to represent the positions of pieces. Since a chess board is always 8x8, a 64-bit string (when seen as a string of 8 bytes) can hold some binary state of a particular Chess board position. Each piece type and colour needs its own bitboard, since a 1 or a 0 is not enough to differentiate between piece types. For instance, a bitboard describing White Pawns will have a 1 at every index in the 64-bit string that has a Pawn present, and will have 0s in all other positions, where the bottom left of the board is the least significant bit, and the top right of the board is the most significant bit.

The main draw of bitboards is the speed at which potential moves can be generated and the board can be modified. For instance, to move all pieces left by one square, all that is required is a left shift by 1 of the bitboard representation.

Although type-level Haskell has no bitwise operators, they could potentially be emulated through the use of pattern matching. Consider "bitwise" logical AND; each possible pair of inputs could be pattern-matched against, and the outputs enumerated. However, this code would be both laborious to write and harder to read; and a bitboard representation's main benefit is speed. Type-level operations like this would definitely not map directly to hardware bitwise operations, and so the main benefit of Bitboards would be lost. A Bitboard representation of Chesskell may indeed be faster than the vector board representation we explain above; however, it would incur a considerable complexity cost that is unlikely to be worth it, especially since type-level computation will be slow anyway. While it would make an interesting extension to Chesskell someday in the future, it is not part of the final feature set described in this dissertation.

\section{Modelling Chess with Functions}

Ideally, the Chess board alone would be sufficient to calculate whether a move was valid. A value-level function for determining the validity of moves could take in the current state of the board, and two positions (the position moving from and the position moving two), and either return the new board state or some king of error. Since Chess is conducted move by move, to simulate a game, this function could be chained repeatedly, with each new move and the previous generated board as input. Such an ideal function could have type \inline{ChessBoard -> Position -> Position -> Maybe ChessBoard}.

In a game of Chess, the majority of moves are time-agnostic; that is, they are not tied to previous moves, only the current state of the board. There are, however, two exceptions; Castling and \emph{en passant} capture. Castling is a move by both a King and a Rook, and an \emph{en passant} capture is a special form of capture available only to Pawns. However, the only additional information required to calculate whether these moves are valid is the last piece that moved, and for each piece the number of times that piece has moved. As such, the board representation can be defined to include this information; ensuring that not only pieces and teams are recorded, but also the number of moves made and the last piece to make a move. Therefore, with a new type \inline{DecoratedChessBoard} containing the new information (as well as the board state), a function for calculating move validity could have type \inline{DecoratedChessBoard -> Position -> Position -> Maybe DecoratedChessBoard}.

A pure function implementation is therefore possible, making use of a Chess board data structure which includes this information. Translating this approach to the type-level, a Type Family (or First Class Family) can be defined which performs similarly, with kind \inline{'DecoratedChessBoard -> 'Position -> 'Position -> 'DecoratedChessBoard}. This type-level model of Chess, implemented as a single movement Type Family, must be interacted with via the defined EDSL. The EDSL is responsible for gathering move-wise positional information, and chaining together calls of the movement Type Family, which will either return a valid Chess board or a type error depending on whether the described move is permissible or not.

\subsection{Checking Chess Rules}

When determining if a given move of Chess is valid or not, the destination squares for all pieces is not sufficient. In other words, a function to generate the valid positions a piece can move to is not enough to enforce all rules of Chess.

Part of the relevant global state for a Chess game is the team that is currently moving; remember, White and Black teams move in an alternating fashion. It breaks the rules of Chess for a White piece to move after a White piece has just moved. There are also a few implicit Chess rules that would be helpful to have more personalised error messages for; such as the fact that no piece can actually take the opposite King. While this information will be encoded in the fact that the opposite King's position will not be in the valid move list for that piece (even though the piece can indeed attack that position), it would be helpful to have a more specific error message for this case. Instead of \inline{error: The Piece cannot move to that position}, it should say something like \inline{error: Pieces cannot take their King}.

In Chesskell, an early idea was to simply check for these invariants with either type-level if statements or pattern matching. However, as the number of invariants with specific error messages grows, so too would the number of nested if statements. While such an approach would work, it is harder to follow and rather ugly.

Being in a functional environment, it is natural to express these rule checks as functions that either successfully compute something, or return a type error. Each function could essentially act as an assertion; either the input fulfils some query, or there is an error. For instance, a function \inline{CannotTakeKing :: DecoratedChessBoard -> Position -> DecoratedChessBoard} that takes in the board state and the position to move to, and generates a type error if the position to move to is the position of either of the Kings. The reason it returns a \inline{DecoratedChessBoard} in the successful case is so that it can be naturally composed together with the core movement function, using a First Class Family version of the Haskell function composition operator, \inline{(.)}. Instead of code of the form \inline{(if firstCondition then (if secondCondition then Move a1 a2 else throw "Second error") else throw "First error")}, with more and more nested if conditions, the rule-checking code has the form \inline{(SecondCheck . FirstCheck . Move a1 a2)}, which is much easier to modify and understand.

\section{Designing an EDSL for Chess}

Since the EDSL is for describing games of Chess, it makes sense that it should draw inspiration from Chess game notation, such as Algebraic Notation (which we explain briefly above). In such notation, the board state is implicit and undescribed; that is, the state of the board must be inferred by the reader from the moves made thus far, assuming that the game started in standard configuration (Figure \ref{startboard}).

One possible match in Haskell for this style is monadic computation. If the board information were stored in a custom monad, then the \emph{bind} operator (written as \inline{>>=)}) could be used to chain together these chess moves, in some way akin to below:

\begin{lstlisting}
game = chessStart
    >>= move e2 e4
    >>= move e7 e5
    >>= -- ...
\end{lstlisting}

However, this approach introduces a few problems. Firstly, the EDSL is more difficult to read for those unfamiliar with Haskell. It immediately would be less an EDSL, and more a set of plain Haskell functions with nice names. Secondly, it is not immediately clear how a monad for the type-level chess board could be defined. It could piggyback off of another defined monad, such as the \inline{Maybe} monad, but this is introducing further complexity for no good reason.

Luckily, there exists an alternative; Continuation Passing Style (CPS). The core idea is value transformation through a series of continuation function applications, until the final continuation function returns a value. Due to the left-to-right composition of functions, CPS results in very readable code, and could be utilised to avoid any Haskell-specific operators and appear as a clear stretch of Chess notation.

Consider the following example of CPS code. We give the definition of two functions, \inline{add} and \inline{to}:

\begin{lstlisting}
add :: Int -> ((Int -> Int) -> m) -> m
add x cont = cont (+ x)

to :: (Int -> Int) -> Int -> Int
to f x = f x
\end{lstlisting}

With the definition of these two functions, the line \inline{add 5 to 7} is well-typed, and evaluates to \inline{12}. This is because \inline{add} takes in a continuation of type \inline{(Int -> Int) -> m}, and returns a value of type \inline{m}. In other words, the continuation (in this case \inline{to} is responsible for the output. Using such a scheme enables Chesskell to be much closer to conventional chess notation than to Haskell code, and avoids wrapping the types in an unrelated monadic context.


\chapter{Implementation} \label{examplegame}

The final product of Chesskell allows us to describe games of chess, move-by-move. For example, we express a simple 3-move checkmate by White as follows in Chesskell:

\begin{lstlisting}
game = chess
           p e4 p f5
           q f3 p g5
           q h5
       end
\end{lstlisting}

Note that the spacing is purely for style reasons; the above game could just as easily be written as:

\begin{lstlisting}
game = chess p e4 p f5 q f3 p g5 q h5 end
\end{lstlisting}

Each chess move is described with a type family, which takes as input the current state of the board, and outputs the board after the move has been processed. The core movement function, aptly named \inline{Move}, takes in the position to move from, the position to move to, and the current state of the board, using this information to return a new board state in which the move has been made:

\begin{lstlisting}
data Move :: Position -> Position -> BoardDecorator -> Exp BoardDecorator
\end{lstlisting}

The EDSL, as we explain in more detail below, uses this \inline{Move} function to perform type-level rule checking of the described chess game. While the continuation-passing style (CPS) structure complicates the relevant types, the intuition of the EDSL is to take in the current board state, as well as the positions to move from and to, and output the new board state generated by that move. A simplified non-CPS example is below, to aid understanding:

\begin{lstlisting}
edslMove :: SPosition from -> SPosition to -> Proxy (b :: Board) -> Proxy (Eval (Move from to b))
edslMove (x :: SPosition from) (y :: SPosition to) (z :: Proxy (b :: Board)) = Proxy @(Eval (Move from to b))
\end{lstlisting}

\section{Type-Level Chess}

The software has a full representation of a game of chess at the type-level, as we explain below. The model is checked move-by-move, with the current board state, as well as some further information, carried between moves via a \inline{BoardDecorator}. This \inline{BoardDecorator} contains all information necessary to encapsulate the current state of a game of chess; in other words, Chesskell does not rely on any global state, and the state of the game is modifiable easily.

\subsection{Chess Types and Kinds}

The \inline{Board} type is the most important type in Chesskell, representing the chess board at the type-level. It is a \emph{composite type} containing all pieces in play. However, \inline{Board} types are usually accessed through a  \inline{BoardDecorator}, which we detail below.

We describe Chesskell's types from the bottom up in the following sections, since the types here are composite and require understanding of other types.

\subsubsection{Team and PieceName}

Both \inline{Team} and \inline{PieceName} are simple algebraic data types, with all constructors defined in code. The \inline{Team} type enumerates all teams a piece can belong to; \inline{Black} and \inline{White}. The \inline{PieceName} type enumerates all possible names of pieces; Pawn, Rook, and so on. Thanks to promotion, as we explain above, these types are immediately available for use with Type Families.

\begin{lstlisting}
data Team = Black | White
data PieceName = Pawn
               | Bishop
               | Knight
               | Rook
               | King
               | Queen
\end{lstlisting}

\subsubsection{Position}

The \inline{Position} type holds the positions of pieces on the chess board. It makes use of two more types, one for columns and the other for rows. In chess, columns are labelled with letters and rows are labelled with numbers; "a1" is the top-left of the board, and "h8" is the bottom-right. The \inline{Column} type is another simple algebraic data type enumerating all columns that a piece can reside within. The row type is a type-level implementation of Peano natural numbers, named \inline{Nat}. Early versions of Chesskell had a custom implementation, but the current version simply uses definitions provided in \inline{Data.Type.Nat}.

\begin{lstlisting}
data Column = A | B | C | D | E | F | G | H
data Nat where
    Z :: Nat
    S :: Nat -> Nat
\end{lstlisting}

Note that the \inline{Position} kind has a potentially infinite number of valid types, but only 64 of these types are valid chess positions. As such, there is a type family, \inline{IsValidPosition}, which outputs \inline{True} if the given position is a valid chess position, and \inline{False} otherwise.

\begin{lstlisting}
data Position where
    At :: Column -> Nat -> Position
\end{lstlisting}

\subsubsection{The Pieces}

Each piece, represented by the \inline{Piece} type, contains information relevant for rule checking: that piece's team, name, and an information type. The information type, named \inline{PieceInfo}, contains a \inline{Nat} and a \inline{Position}, to represent the number of moves that piece has taken, and its current position on the board (respectively). Recording the number of moves the piece has taken is important for several rules in chess, including castling and \textit{en passant}, and so is included in the \inline{PieceInfo} type.

The \inline{PieceInfo} type was created separately from the plain \inline{Piece} type so that if any further information was required, it could be added without breaking existing \inline{Piece} pattern-match definitions (though no such additional information was required).

\begin{lstlisting}
data PieceInfo where
    Info :: Nat -> Position -> PieceInfo

data Piece where
    MkPiece :: Team -> PieceName -> PieceInfo -> Piece
\end{lstlisting}

\subsubsection{The Board}

We explain above that length-indexed vectors are an ideal choice for representing the Chess board. The board can be expressed using these vectors---a vector of 8 vectors of 8 \inline{Maybe Piece}-s. We use \inline{Maybe Piece} instead of just \inline{Piece} because a board square does not necessarily contain a piece (in fact, the majority of board squares are empty):

\begin{lstlisting}
type Eight = (S (S (S (S (S (S (S (S Z))))))))
type Row   = Vec Eight (Maybe Piece)
type Board = Vec Eight Row
\end{lstlisting}

Although this is the main board type, it is augmented with a \inline{BoardDecorator}, so named because the intention is similar to the decorator design pattern \cite{decorator}, with the exception that subclassing and superclassing are not features of Haskell. \inline{BoardDecorator} should be used instead of \inline{Board}, since it provides additional information:

\begin{itemize}
    \item The last team to move;
    \item The last position moved to;
    \item The White and Black King positions, stored as a tuple;
    \item The number of moves in the game thus far.
\end{itemize}

Previous versions of the program, to find the King positions, would pass repeatedly over the \inline{Board}. Having their positions available in the decorator saves Chesskell from making these passes. While there is the overhead that the \inline{BoardDecorator} must be updated at each move, the code is much conceptually clearer with the use of the decorator.

\begin{lstlisting}
data BoardDecorator where
    Dec :: Board -> Team -> Position -> (Position, Position) -> Nat -> BoardDecorator
\end{lstlisting}

\subsubsection{Miscellaneous Types}

\subsection{Chess Rules}

\subsubsection{Movement Rules}

\subsubsection{Attack/Capture Rules}

\subsubsection{Checking For Violations}

\subsubsection{Exceptions}

\paragraph{Castling}

\paragraph{Pawn Capture and En Passant}

\section{The EDSL}

\subsection{Minimum Viable Product}

\subsection{Flat Builders}

\subsection{Moving the pieces}

\subsection{Setting up a board}


\chapter{Evaluation}

\section{Testing}

\subsection{Type-level Unit Testing}

\subsection{Testing Chesskell Games}

\section{Compile Time and Memory Usage}

\subsection{Optimisation Attempts}

\subsubsection{Board Decorators}

\subsubsection{Finger Trees}

\subsection{GHC Bug Report}

\subsection{Descriptive Error Messages}

\subsubsection{Move Number}

\subsection{Chesskell Shorthand}

\section{Chesskell EDSL vs Other Chess Notations}


\chapter{Conclusions}

Chesskell is a successful project. ...

\section{Results and Accomplishments}

\section{Future Work}

\subsection{Session-typed Chesskell}

\subsection{Type-level Bitboards}

% TODO: Map each natural number (with pattern matching) to an 8-tuple of Booleans
% BUT it would make code less idiomatic, and wouldn't map to hardware bitwise operations (so still slow)

\bibliographystyle{ieeetr}

\bibliography{diss}

\chapter{Appendix}

\begin{figure}
    \fenboard{8/8/8/8/8/8/8/8 w - - 0 1}
    \showboard
    \caption{An empty chess board.}
    \label{chessboard}
\end{figure}

\begin{figure}
    \newgame
    \showboard
    \caption{An standard chess board where all pieces are in their starting position.}
    \label{startboard}
\end{figure}

\begin{figure}
    \fenboard{8/8/2Q5/8/4p3/8/8/8 w - - 0 1}
    \showboard
    \quad
    \hidemoves{1.Qe4}
    \showboard
    \caption{The White Queen captures a Black Pawn by moving to its position, and removing it from play.}
    \label{capture}
\end{figure}

\begin{figure}
    \fenboard{8/8/8/8/8/4Q3/8/R3k3 w - - 0 1}
    \showboard
    \caption{The White Queen and White Rook place the Black King into checkmate.}
    \label{checkmate}
\end{figure}

\begin{figure}
    \newgame
    \hidemoves{1.e4 e5 2. Nf3 Nc6 3.Bb5 a6}
    \showboard
    \caption{The position of the board after: 1.e4 e5 2. Nf3 Nc6 3.Bb5 a6}
    \label{algebraicexample}
\end{figure}

\begin{figure}
    \fenboard{rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b - - 0 1}
    \showboard
    \caption{The board created with: (rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1)}
    \label{fenexample}
\end{figure}

\end{document}