\documentclass[12pt, a4paper, bibliography=totocnumbered]{scrreprt}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{FiraSans}
\usepackage{palatino}
\usepackage[T1]{fontenc}  % Correct formatting for >, <, |, etc.
\usepackage{FiraMono}  % Keep last to maintain monospace font
\usepackage{xcolor}
\usepackage{parskip}
\usepackage[multiple]{footmisc}

\definecolor{background}{rgb}{0.97, 0.97, 0.97}
\definecolor{comments}{rgb}{0.0, 0.64, 0.0}
\definecolor{keywords}{rgb}{0.0, 0.0, 0.64}
\definecolor{identifiers}{rgb}{0.63, 0.81, 0.94}
\definecolor{strings}{rgb}{1.0, 0.6, 0.4}

\lstset{
    language=haskell,
    basicstyle=\small\ttfamily,
    backgroundcolor=\color{background},
    keywordstyle=\color{keywords}\bfseries,
    commentstyle=\color{comments}\textit,
    stringstyle=\color{strings},
    % identifierstyle=\color{identifiers},
    breakatwhitespace=true,
    breaklines=true,
    keepspaces=true,
    captionpos=b,
    frame=tlbr,    % Margin at all 4 sides
    framesep=4pt,  % Margin size
    framerule=0pt
}

\setkomafont{sectioning}{\firamedium}

% Change abstract appearance
\renewenvironment{abstract}
 {\small
  \begin{center}
  \bfseries \textit{\abstractname}\vspace{-.5em}\vspace{0pt}
  \end{center}
  \quotation}
 {\endquotation}

% Custom command for all inline code styling
\newcommand{\inline}[1]{\lstinline[basicstyle=\ttfamily]{#1}}

\title{Chesskell: Embedding a Two-Player Game in Haskell's type system}
\subtitle{University of Warwick Dissertation}
\author{Toby Bailey}
\date{\today}

\begin{document}

{
\renewcommand{\normalfont}{\usekomafont{sectioning}}
\begin{titlepage}
    \maketitle
    \usekomafont{sectioning}{\tableofcontents}
\end{titlepage}
}

\begin{abstract}
    Type-level programming, a relatively recent phenomenon, allows programmers to express computation during the compilation of their programs. Through the use of type-level constructs, rules can be imposed on code to ensure that if it compiles, then it behaves in a certain way. However, there is still plenty of room to push the boundaries of what can be achieved with type-level programming.

    Chess has a well-defined ruleset, and has not been expressed at the type level before. This dissertation describes the development of Chesskell, a Haskell-Embedded Domain-Specific Language to notate Chess games within. If the Chesskell code compiles, then the match described obeys the full International Chess Federation ruleset for Chess. Despite difficulties during development, including memory issues, the final version of Chesskell is feature-complete and supports Chess games of up to 10 moves.

    \textbf{\textit{Keywords:}} Type-level Programming, Haskell, Chess, EDSL.
\end{abstract}

\part{Introduction}

\chapter{Motivation}

In 2021, video games are more popular than ever. In the US alone, a 2020 ESA report\footnote{\url{https://www.theesa.com/wp-content/uploads/2020/07/Final-Edited-2020-ESA_Essential_facts.pdf}} estimated that there were more than 214 million individuals who play games. Considering this, it's surprising how many games are released with major bugs in their software---some of which end up being so notable that news and footage of them appear on mainstream media\footnote{\url{https://www.bbc.co.uk/news/technology-50156033}}.

As programming languages have evolved, many have begun to address more errors at compile time. Features similar to optional types have been added to languages such as Java\footnote{\url{https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html}} and C\#\footnote{\url{https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references}}, and languages like Rust have pioneered ways of safely handling dynamic allocation through ownership types\footnote{\url{https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html}}. Many compilers now force the developer to handle classes of errors that previously could only be encountered at runtime, such as null pointer exceptions.

However, catching logical errors in imperative languages is almost always done during execution. Many software systems use runtime features such as exceptions to discover and deal with errors and misuse of APIs. Enforcement of invariants and rules is typically dynamic; if a check fails, an exception is thrown and potentially handled. However, if a programmer forgets to implement such a check, the behaviour is unpredictable. A 2007 study \cite{exceptionsusedpoorly} on Java and .NET codebases indicates that exceptions are rarely used to recover from errors, and a 2016 analysis of Java codebases \cite{badjavaexceptions} reveals that exceptions are commonly misused in Java.

Recent versions of the \emph{Glasgow Haskell Compiler} (GHC) support programming at the type level, allowing programmers to compute with types in the same way that languages like C or Python compute with values \cite{yorgey2012giving}, using \emph{type families} \cite{opentfs} \cite{closedtfs} that emulate functions at the type-level. These computations run at compile time, before the compiler generates an executable of the source code, allowing programmers to transform logic errors into type errors \cite{twt}. The exception misuse described above could be avoided by employing logical invariant checks at the type-level, rather than at runtime.

Since these are relatively recent developments, there are few examples of their usage in complex applications. In this project, we show how to utilise type-level programming features in Haskell in order to model the classic board game Chess in Haskell's type system, ruling out invalid moves at the type-level. A Haskell-Embedded Domain-Specific Language (DSL), for describing games of Chess, will interact with the type-level model. This Embedded DSL (EDSL) will be modelled on Algebraic Notation, a method of writing down the moves associated with a particular match of Chess. We implement the full, official International Chess Federation (FIDE) ruleset for Chess.

\chapter{History}

Programming languages have \emph{type systems} for the main purpose of avoiding errors \cite{cardellitypes}. A \emph{type error} is an instance of attempting to perform a computation on something which does not support that computation. For example, it makes no logical sense to add the number 3 to a dog. This stems from the fact that "3" and "dog" support different behaviours\footnote{For instance, dogs can bark, but the number 3 cannot.}. Therefore, in a programming context, "3" and "dog" have distinct types; 3 is a number, and a dog is an animal. By assigning a type to values, programmers and the languages they use have an easier way to determine the valid operations on a value, and avoid type errors through misuse.

A notable area in which languages differ is \emph{when} they detect type errors. A \emph{static} type system is one in which type errors are detected before the program is run (during compilation), and a \emph{dynamic} type system is one in which type errors are detected while the program is running. A static type system is preferable for runtime safety, since it ensures that any running program will avoid (at least some) type errors.

A growing number of new languages have type systems which support \emph{Dependent types}, in which the types themselves depend on runtime values, and can be treated as values. The programming language Idris is similar to Haskell, but allows the programmer to pass around types at runtime, and write functions which operate on those types. Many of Haskell's language extensions have been adding to its type system, moving the language closer and closer towards dependently typed programming \cite{singletons}. Such a type system has various benefits, since constraining the types means constraining the values without dynamic runtime checks. (For example, in a dependently typed environment, runtime array bounds checks can be eliminated at runtime through being expressed solely in the type system \cite{dependentarray}.)

Chess was chosen as a suitable game to model at the type-level due to its well-defined ruleset. Programming language type systems will evolve through usage, and so programs will and should be written to test what's possible to express at the type level. Chess is a widely understood, popular, and rigorously documented game, making it a natural fit to help push the boundaries of type-level programming. Simulating, and checking for rule violations within, a Chess game has a much wider scope than using type-level programming to avoid some dynamic checks. This project uses Chess as a case study for complex rule systems, to determine if such a thing can be modelled at the type level.

\chapter{Objectives}

The objective of this project is to develop an EDSL, nicknamed Chesskell, with which to express games of Chess. During compilation, the game of Chess will be simulated, such that any invalid move (or the lack of a move where one should have occurred) will result in a type error. The main goals are thus:

\begin{itemize}
    \item Develop a type-level model of a Chess board;
    \item Develop a type-level move-wise simulation of a Chess game;
    \item Develop an EDSL to express these type-level Chess games in;
    \item Ensure (through testing) that valid Chess games compile, and invalid Chess games do not.
\end{itemize}

During the course of the project, a "valid Chess game" is any game that adheres to the FIDE 2018 Laws of Chess\footnote{\url{https://handbook.fide.com/chapter/E012018}}. The FIDE laws also contain rules for the players themselves to adhere to; but these are outside the scope of the project, since they are not directly concerning the game of Chess itself.

\part{Background}

\chapter{Related Work}

Chesskell is, at the time of writing, unique; we are aware of no other type-level chess implementations. There have been allusions to Chess at the type-level through solving the N-queens problem in dependently typed languages, such as Idris\footnote{\url{https://github.com/ExNexu/nqueens-idris}}. The N-queens problem makes use of some chess rules, including the Queen's attack positions\footnote{A Queen can attack in a straight line in any direction.}; but as the end goal is not to successfully model a game of chess, it is not a full type-level chess implementation.

However, Chesskell draws from many well-established research areas, including type-level rule checking, EDSLs, and chess programming in general. This section of the report will detail related work, and how Chesskell differs from existing literature.

\section{Type-level Rule Checking}

The idea of using types to enforce rules on behaviour is hardly specific to Haskell; C and C-like languages ensure that you only apply the correct operations on types, after all. However, with the advent of more complex type systems and type-level programming, more and more rules can be expressed in the types, to ensure that compiled programs follow those rules.

The programming language Rust\footnote{\url{https://www.rust-lang.org/}} has been voted the most loved language (by StackOverflow developers) 5 years running\footnote{\url{https://insights.stackoverflow.com/survey/2020\#technology-most-loved-dreaded-and-wanted-languages}}. Rust is touted as a systems language that guarantees memory safety and thread safety; and it achieves this through its type system. By enforcing strict ownership rules, Rust can guarantee that your programs avoid data races and that all memory is freed once and not used after being freed. This is a clear example of types enforcing runtime behaviour; but instead of Chess rules, a series of memory rules are being enforced. In fact, Haskell type-level constructs can be used to enforce basic ownership rules through a method colloquially known as the "ST Trick" \cite{twt}.

Examples of type-level rule checking in more Functional languages include... % TODO: This

\section{Embedded Domain-Specific Languages}

Despite the apparent lack of work on Chess at the type level specifically, there is work on Haskell-Embedded DSLs in other domains to enforce certain behaviour at compile time. Mezzo \cite{mezzohaskellsymposium} is an EDSL for music composition, which checks if the described piece of music conforms to some musical ruleset during compilation of the program. This EDSL is similar to Chesskell in aim, if not in application domain; performing compile-time checks of rulesets that are commonly checked at runtime.

As another example, BioShake \cite{bioshake} is an EDSL for creating performant bioinformatics computational workflows. The correctness of these workflows is checked during compilation, preventing any from being created if their execution would result in certain errors. For bioinformatics workflows especially, this is ideal since many of these workflows are lengthy. BioShake goes further, however; providing tools to allow parallel execution of these workflows. While it is encouraging to see BioShake and other EDSLs \cite{aplite} focus on (and achieve) high performance, Chesskell will have no such focus. This is primarily because very few parts of the rule-checking process can be parallelised; much of the move handling and order of rule checks must be done sequentially.

\chapter{The Basics of Chess}

\section{The Board}

\subsection{The Pieces}

\section{The Game}

\section{Chess Notation}

\chapter{Chess In Computer Science}

\section{Chess Programs}

Chess has a rich history in Computer Science. Getting computers to play Chess was a concern back in 1949 \cite{1949chess}, and since then many developments have been made in the field. Chess has been used to educate \cite{chesseducation}, to entertain, and to test out machine learning approaches \cite{chessml}. Due to its status as a widely known game of logic, with a well-defined rule set, it is a prime candidate to act as the general setting for programming problems. Indeed, the famous NP-Complete problem referenced above, the N-Queens Problem \cite{nqueensnp}, relies on the rules of Chess.

Many of these chess-related programs are written in Haskell, and are publicly available\footnote{\url{https://github.com/mlang/chessIO}}\footnote{\url{https://github.com/nionita/Barbarossa}}. Many of them are chess engines, which take in a board state and output the move(s) which are strongest, and so therefore perform move checking at the value-level to ensure that the moves that it outputs are valid. Chesskell differs from these in function, in that the end software will not output a list of strong moves; it will simply take in the moves performed, and state whether they are valid chess moves or not. We are not aware of any such type-level chess implementations in Haskell, or any other language.

Game development, as a more general field in Computer Science, has many Chess-based or Chess-related games available. However, the intention in these cases is usually to facilitate real-time play between multiple players (or indeed a single player with a competitive AI), rather than to teach or program a machine to consistently beat players. There is overlap with Chesskell; Chess as a computer game must necessarily perform move validation (to disallow cheating) and ensure that players take turns. However, Chesskell is intended to check over a complete game, rather than to enable people to conduct a game in real-time with Chesskell as a mediator.

\section{Chess Data Structures}

An important part of any good chess program is its board representation, since all other parts of the program come from this; move generation, move evaluation, and the entire search space are all defined or influenced by the board representation. A great deal of work has gone into defining memory- or time-efficient chess boards \cite{bitboard} \cite{searchtables}, including combinations of multiple representations to yield greater speed \cite{bitandccr}. While there is value to be gleaned from examining these representations, Chesskell serves a different purpose; it does not need to search through the valid set of moves to determine which are the best, and speed is not its focus. Chesskell's board representation must be relatively efficient, but it would be naive to expect similar levels of performance from type-level constraint solving computation as from optimised term-level code.


\part{Design}

\chapter{Type-level Programming}

\section{Type Families}

\section{First-Class Families}

\section{Type-Level Data Structures}

\chapter{Giving Runtime Information to the Compiler}

\chapter{Development Approach}

\section{Methodology}

\section{Testing}


\part{Implementation}

\chapter{Type-Level Chess}

\section{Chess Types and Kinds}

\subsection{The Pieces}

\subsection{The Board}

\subsection{Miscellaneous Types}

\section{Chess Rules}

\subsection{Movement Rules}

\subsection{Attack/Capture Rules}

\subsection{Checking For Violations}

\subsection{Exceptions}

\subsubsection{Castling}

\subsubsection{Pawn Capture and En Passant}

\chapter{The EDSL}

\section{Minimum Viable Product}

\section{Flat Builders}

\section{Moving the pieces}

\section{Setting up a board}

\chapter{Testing}

\section{Type-level Unit Testing}

\section{Testing Chesskell Games}


\part{Evaluation}

\chapter{Difficulties}

\section{Session-typed Chesskell}

\section{Compile Time and Memory Usage}

\subsection{Optimisation Attempts}

\subsubsection{Board Decorators}

\subsubsection{Finger Trees}

\subsection{GHC Bug Report}

\section{Descriptive Error Messages}

\subsection{Move Number}

\chapter{Chesskell EDSL vs Other Chess Notations}


\part{Conclusion}

\chapter{Results and Accomplishments}

\chapter{Future Work}


\part{Appendix}



\bibliographystyle{ieeetr}

\bibliography{diss}

\end{document}